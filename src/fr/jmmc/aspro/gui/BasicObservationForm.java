/*******************************************************************************
 * JMMC project
 *
 * "@(#) $Id: BasicObservationForm.java,v 1.22 2010-04-06 14:40:47 bourgesl Exp $"
 *
 * History
 * -------
 * $Log: not supported by cvs2svn $
 * Revision 1.21  2010/04/02 10:05:08  bourgesl
 * minor visual changes
 *
 * Revision 1.20  2010/02/16 14:48:26  bourgesl
 * if the model editor was successfull (ok), update the plots
 *
 * Revision 1.19  2010/02/12 15:53:18  bourgesl
 * added target model editor
 *
 * Revision 1.18  2010/01/21 16:39:11  bourgesl
 * simplified StarResolverWidget integration
 *
 * Revision 1.17  2010/01/20 16:18:37  bourgesl
 * observation form refactoring
 *
 * Revision 1.16  2010/01/14 17:03:37  bourgesl
 * refactoring for observation LOAD / CHANGE events
 *
 * Revision 1.15  2010/01/08 16:51:17  bourgesl
 * initial uv coverage
 *
 * Revision 1.14  2010/01/04 15:42:47  bourgesl
 * added missing fields in Target : proper motion, parallax, magnitudes and spectral types (cds raw data)
 *
 * Revision 1.13  2009/12/18 14:50:11  bourgesl
 * check StarResolverWidget notification to process only valid CDS star results
 *
 * Revision 1.12  2009/12/15 16:32:44  bourgesl
 * added user PoP configuration based on PoP indices
 *
 * Revision 1.11  2009/12/11 16:37:32  bourgesl
 * added Pop field in observation form
 *
 * Revision 1.10  2009/12/07 15:17:59  bourgesl
 * Load observation action now refreshes the observation form completely
 *
 * Revision 1.9  2009/12/04 15:38:27  bourgesl
 * Added Save action in the menu bar
 *
 * Revision 1.8  2009/11/24 15:12:09  bourgesl
 * first step to handle delay line limits
 *
 * Revision 1.7  2009/11/17 17:00:28  bourgesl
 * chosen instrument configuration propagated to observation
 *
 * Revision 1.6  2009/11/05 12:59:39  bourgesl
 * first simple source observability (only min elevation condition)
 *
 * Revision 1.5  2009/10/22 15:47:22  bourgesl
 * beginning of observability computation with jSkyCalc
 *
 *
 *
 ******************************************************************************/
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.AsproConstants;
import fr.jmmc.aspro.model.ConfigurationManager;
import fr.jmmc.aspro.model.ObservationListener;
import fr.jmmc.aspro.model.ObservationManager;
import fr.jmmc.aspro.model.oi.FocalInstrumentConfigurationChoice;
import fr.jmmc.aspro.model.oi.InterferometerConfiguration;
import fr.jmmc.aspro.model.oi.InterferometerConfigurationChoice;
import fr.jmmc.aspro.model.oi.ObservationSetting;
import fr.jmmc.aspro.model.oi.Pop;
import fr.jmmc.mcs.astro.star.Star;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import java.util.logging.Level;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JFormattedTextField;
import javax.swing.JOptionPane;
import javax.swing.JSpinner;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import javax.xml.datatype.XMLGregorianCalendar;

/**
 * This form allows the user to select main observation settings : date, interferometer, configuration, stations and targets ...
 * @author bourgesl
 */
public class BasicObservationForm extends javax.swing.JPanel implements ChangeListener, ActionListener, Observer, ObservationListener {

  /** default serial UID for Serializable interface */
  private static final long serialVersionUID = 1;
  /** Class Name */
  private static final String className_ = "fr.jmmc.aspro.gui.BasicObservationForm";
  /** Class logger */
  private static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
          className_);

  /* members */
  /** observation manager */
  private ObservationManager om = ObservationManager.getInstance();
  /** flag to enable / disable the automatic update of the observation when any swing component changes */
  private boolean doAutoUpdateObservation = true;

  /** Creates new form BasicObservationForm */
  public BasicObservationForm() {
    initComponents();
    postInit();
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;

    jPanelMain = new javax.swing.JPanel();
    jLabel2 = new javax.swing.JLabel();
    jComboBoxInterferometer = new javax.swing.JComboBox();
    jLabelPeriod = new javax.swing.JLabel();
    jComboBoxInterferometerConfiguration = new javax.swing.JComboBox();
    jLabel3 = new javax.swing.JLabel();
    jComboBoxInstrument = new javax.swing.JComboBox();
    jLabelConfiguration = new javax.swing.JLabel();
    jComboBoxInstrumentConfiguration = new javax.swing.JComboBox();
    jLabelPops = new javax.swing.JLabel();
    jTextPoPs = new JFormattedTextField(getPopsFormatter());
    jLabel4 = new javax.swing.JLabel();
    jScrollPane1 = new javax.swing.JScrollPane();
    jListTargets = new javax.swing.JList();
    jButtonRemoveTarget = new javax.swing.JButton();
    starSearchField = new fr.jmmc.mcs.astro.star.StarResolverWidget();
    jButtonModelEditor = new javax.swing.JButton();
    jPanelOptions = new javax.swing.JPanel();
    jLabel1 = new javax.swing.JLabel();
    jDateSpinner = new javax.swing.JSpinner();
    jLabel5 = new javax.swing.JLabel();
    jFieldMinElev = new javax.swing.JFormattedTextField();
    jCheckBoxNightLimit = new javax.swing.JCheckBox();

    setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));

    jPanelMain.setBorder(javax.swing.BorderFactory.createTitledBorder("Observation"));
    jPanelMain.setLayout(new java.awt.GridBagLayout());

    jLabel2.setLabelFor(jComboBoxInterferometer);
    jLabel2.setText("Interferometer");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 5;
    gridBagConstraints.ipady = 4;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabel2, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jComboBoxInterferometer, gridBagConstraints);

    jLabelPeriod.setLabelFor(jComboBoxInstrumentConfiguration);
    jLabelPeriod.setText("Period");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabelPeriod, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 4;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jComboBoxInterferometerConfiguration, gridBagConstraints);

    jLabel3.setLabelFor(jComboBoxInstrument);
    jLabel3.setText("Instrument");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabel3, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jComboBoxInstrument, gridBagConstraints);

    jLabelConfiguration.setLabelFor(jComboBoxInstrumentConfiguration);
    jLabelConfiguration.setText("Configuration");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabelConfiguration, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 4;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jComboBoxInstrumentConfiguration, gridBagConstraints);

    jLabelPops.setLabelFor(jTextPoPs);
    jLabelPops.setText("PoPs");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 5;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabelPops, gridBagConstraints);

    jTextPoPs.setColumns(4);
    jTextPoPs.setMinimumSize(new java.awt.Dimension(40, 20));
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 6;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jTextPoPs, gridBagConstraints);

    jLabel4.setLabelFor(jListTargets);
    jLabel4.setText("Targets");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jLabel4, gridBagConstraints);

    jScrollPane1.setPreferredSize(new java.awt.Dimension(100, 50));

    jListTargets.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
    jListTargets.setVisibleRowCount(3);
    jScrollPane1.setViewportView(jListTargets);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jScrollPane1, gridBagConstraints);

    jButtonRemoveTarget.setFont(new java.awt.Font("Dialog", 1, 14));
    jButtonRemoveTarget.setIcon(new javax.swing.ImageIcon(getClass().getResource("/fr/jmmc/aspro/gui/icons/delete.png"))); // NOI18N
    jButtonRemoveTarget.setMargin(new java.awt.Insets(0, 0, 0, 0));
    jButtonRemoveTarget.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonRemoveTargetActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jButtonRemoveTarget, gridBagConstraints);

    starSearchField.setMinimumSize(new java.awt.Dimension(80, 23));
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(starSearchField, gridBagConstraints);

    jButtonModelEditor.setText("Model editor");
    jButtonModelEditor.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonModelEditorActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 5;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.insets = new java.awt.Insets(1, 1, 1, 1);
    jPanelMain.add(jButtonModelEditor, gridBagConstraints);

    add(jPanelMain);

    jPanelOptions.setBorder(javax.swing.BorderFactory.createTitledBorder("Constraints"));
    jPanelOptions.setLayout(new java.awt.GridBagLayout());

    jLabel1.setLabelFor(jDateSpinner);
    jLabel1.setText("Date");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    jPanelOptions.add(jLabel1, gridBagConstraints);

    jDateSpinner.setModel(new javax.swing.SpinnerDateModel());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    jPanelOptions.add(jDateSpinner, gridBagConstraints);

    jLabel5.setLabelFor(jFieldMinElev);
    jLabel5.setText("Min. Elevation");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    jPanelOptions.add(jLabel5, gridBagConstraints);

    jFieldMinElev.setColumns(2);
    jFieldMinElev.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(new java.text.DecimalFormat("#0"))));
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    jPanelOptions.add(jFieldMinElev, gridBagConstraints);

    jCheckBoxNightLimit.setText("Night restriction");
    jCheckBoxNightLimit.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
    jCheckBoxNightLimit.setMargin(new java.awt.Insets(0, 0, 0, 0));
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    jPanelOptions.add(jCheckBoxNightLimit, gridBagConstraints);

    add(jPanelOptions);
  }// </editor-fold>//GEN-END:initComponents

  /**
   * Process the remove target action
   * @param evt action event
   */
  private void jButtonRemoveTargetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRemoveTargetActionPerformed
    final String targetName = (String) this.jListTargets.getSelectedValue();

    if (targetName != null) {
      final int answer = JOptionPane.showConfirmDialog(this.jButtonRemoveTarget, "Do you want to remove the target [" + targetName + "] ?");
      if (answer == JOptionPane.YES_OPTION) {
        if (this.om.removeTarget(targetName)) {
          // update target list :
          updateListTargets();

          this.om.fireObservationChanged();
        }
      }
    }
  }//GEN-LAST:event_jButtonRemoveTargetActionPerformed

  private void jButtonModelEditorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonModelEditorActionPerformed

    final String targetName = (String) this.jListTargets.getSelectedValue();

    // show model editor :
    if (TargetModelForm.showModelEditor(targetName)) {
      // fire an observation change event :
      this.om.fireObservationChanged();
    }
  }//GEN-LAST:event_jButtonModelEditorActionPerformed

  /**
   * Return the Pops custom formatter : number format that accepts null values
   * @return number formatter
   */
  private NumberFormatter getPopsFormatter() {
    final NumberFormatter nf = new NumberFormatter(new DecimalFormat("####")) {

      /** default serial UID for Serializable interface */
      private static final long serialVersionUID = 1;

      /**
       * Hack to allow empty string
       */
      @Override
      public Object stringToValue(String text) throws ParseException {
        if (text == null || text.length() == 0) {
          return null;
        }
        return super.stringToValue(text);
      }
    };
    nf.setValueClass(Integer.class);
    // reject invalid characters (digits only)
    nf.setAllowsInvalid(false);
    nf.setCommitsOnValidEdit(false);
    return nf;
  }

  /**
   * This method is useful to set the models and specific features of initialized swing components.
   * Add the star search field and refresh content of the combo boxes.
   * Finally update the observation according to the form state
   */
  private void postInit() {

    // register this as an observation listener :
    this.om.register(this);

    // add observer to the StarResolverWidget :
    this.starSearchField.getStar().addObserver(this);

    // update component models :
    this.jDateSpinner.setEditor(new JSpinner.DateEditor(jDateSpinner, "yyyy/MM/dd"));

    this.jComboBoxInterferometer.setModel(new DefaultComboBoxModel(ConfigurationManager.getInstance().getInterferometerNames()));

    // default values :
    this.jCheckBoxNightLimit.setSelected(AsproConstants.DEFAULT_USE_NIGHT_LIMITS);
    this.jFieldMinElev.setValue(AsproConstants.DEFAULT_MIN_ELEVATION);

    // define change listeners :
    this.jDateSpinner.addChangeListener(this);
    this.jComboBoxInterferometer.addActionListener(this);
    this.jComboBoxInterferometerConfiguration.addActionListener(this);
    this.jComboBoxInstrument.addActionListener(this);
    this.jComboBoxInstrumentConfiguration.addActionListener(this);

    this.jTextPoPs.addPropertyChangeListener("value", new PropertyChangeListener() {

      public void propertyChange(final PropertyChangeEvent evt) {
        jTextPoPsPropertyChange(evt);
      }
    });

    this.jFieldMinElev.addPropertyChangeListener("value", new PropertyChangeListener() {

      public void propertyChange(final PropertyChangeEvent evt) {
        final double minElevNew = ((Number) jFieldMinElev.getValue()).doubleValue();

        if (minElevNew < 0d || minElevNew >= 90d) {
          // invalid value :
          jFieldMinElev.setValue(AsproConstants.DEFAULT_MIN_ELEVATION);
        }
        updateObservation();
      }
    });

    this.jCheckBoxNightLimit.addItemListener(new ItemListener() {

      public void itemStateChanged(final ItemEvent e) {
        updateObservation();
      }
    });

    // update combo boxes :
    updateComboInterferometerConfiguration();
    updateComboInstrument();
    updateComboInstrumentConfiguration();
    updateListTargets();
    checkPops();

    // initial observation synchronization :
    updateObservation();
  }

  /**
   * Refresh the list of interferometer configurations : depends on the chosen interferometer
   */
  private void updateComboInterferometerConfiguration() {
    final Vector<String> v = ConfigurationManager.getInstance().getInterferometerConfigurationNames((String) this.jComboBoxInterferometer.getSelectedItem());
    this.jComboBoxInterferometerConfiguration.setModel(new DefaultComboBoxModel(v));
    final boolean visible = (v.size() > 1);
    this.jLabelPeriod.setVisible(visible);
    this.jComboBoxInterferometerConfiguration.setVisible(visible);
  }

  /**
   * Refresh the list of instruments : depends on the chosen interferometer configuration
   */
  private void updateComboInstrument() {
    final Vector<String> v = ConfigurationManager.getInstance().getInterferometerInstrumentNames((String) this.jComboBoxInterferometerConfiguration.getSelectedItem());
    this.jComboBoxInstrument.setModel(new DefaultComboBoxModel(v));
  }

  /**
   * Refresh the list of instrument configurations : depends on the chosen instrument (also the interferometer configuration)
   */
  private void updateComboInstrumentConfiguration() {
    final Vector<String> v = ConfigurationManager.getInstance().getInstrumentConfigurationNames((String) this.jComboBoxInterferometerConfiguration.getSelectedItem(),
            (String) this.jComboBoxInstrument.getSelectedItem());
    this.jComboBoxInstrumentConfiguration.setModel(new DefaultComboBoxModel(v));
    final boolean visible = (v.size() > 1);
    this.jLabelConfiguration.setVisible(visible);
    this.jComboBoxInstrumentConfiguration.setVisible(visible);
  }

  /**
   * Refresh the target list
   */
  private void updateListTargets() {
    final Vector<String> v = this.om.getTargetNames();
    this.jListTargets.setModel(new DefaultComboBoxModel(v));

    // disable buttons if the target list is empty :
    this.jButtonRemoveTarget.setEnabled(!v.isEmpty());
    this.jButtonModelEditor.setEnabled(!v.isEmpty());
  }

  /**
   * Process any comboBox change event (interferometer, interferometer configuration, instrument, instrument configuration).
   * Refresh the dependent combo boxes and update the observation according to the form state
   * @param e action event
   */
  public void actionPerformed(final ActionEvent e) {
    if (e.getSource() == this.jComboBoxInterferometer) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Interferometer changed : " + this.jComboBoxInterferometer.getSelectedItem());
      }
      updateComboInterferometerConfiguration();
      updateComboInstrument();
      updateComboInstrumentConfiguration();
      checkPops();
    } else if (e.getSource() == this.jComboBoxInterferometerConfiguration) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Interferometer Configuration changed : " + this.jComboBoxInterferometerConfiguration.getSelectedItem());
      }
      updateComboInstrument();
      updateComboInstrumentConfiguration();
    } else if (e.getSource() == this.jComboBoxInstrument) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Instrument changed : " + this.jComboBoxInstrument.getSelectedItem());
      }
      updateComboInstrumentConfiguration();
      checkPops();

    } else if (e.getSource() == this.jComboBoxInstrumentConfiguration) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Instrument Configuration changed : " + this.jComboBoxInstrumentConfiguration.getSelectedItem());
      }
    }
    updateObservation();
  }

  private void checkPops() {
    final boolean hasPops = ConfigurationManager.getInstance().hasPoPs((String) this.jComboBoxInterferometer.getSelectedItem());
    this.jLabelPops.setVisible(hasPops);
    this.jTextPoPs.setVisible(hasPops);
    // reset the pops configuration because it can be invalid because of the chosen instrument
    resetPops();
  }

  /**
   * Process the change event for the PoPs configuration text field.
   * Validates the new input (digits corresponds to valid PoPs indices)
   * @param e action event
   */
  public void jTextPoPsPropertyChange(final PropertyChangeEvent evt) {
    List<Pop> listPoPs = null;

    if (evt.getNewValue() != null) {
      final String popConfig = evt.getNewValue().toString();

      // parse the configuration (instrument = number of channels) + (interferometer = pop indexes [1-5]) :

      listPoPs = ConfigurationManager.getInstance().parseInstrumentPoPs((String) this.jComboBoxInterferometerConfiguration.getSelectedItem(),
              (String) this.jComboBoxInstrument.getSelectedItem(), popConfig);
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("Pops changed = " + evt.getNewValue() + " : " + listPoPs);
    }

    if (listPoPs == null && evt.getNewValue() != null) {
      // invalid, reset the field to empty :
      resetPops();
    }
    // then update the observation :
    updateObservation();
  }

  private void resetPops() {
    // note : setValue() fires a property change event :
    this.jTextPoPs.setValue(null);
  }

  /**
   * Process the date spinner change event.
   * Update the observation according to the form state
   * @param ce change event
   */
  public void stateChanged(final ChangeEvent ce) {
    if (ce.getSource() == this.jDateSpinner) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Date changed : " + this.jDateSpinner.getModel().getValue());
      }
      updateObservation();
    }
  }

  /**
   * Observer implementation used for the StarResolver.
   * Create a new Target object with the retrieved data from SimBAD and
   * fire an observation change event
   * @param o Observable instance
   * @param arg unused argument
   */
  public void update(final Observable o, final Object arg) {
    if (o instanceof Star) {
      final Star star = (Star) o;

      final Star.Notification notification = (Star.Notification) arg;

      if (notification == Star.Notification.QUERY_COMPLETE) {
        if (logger.isLoggable(Level.FINE)) {
          logger.fine("Star resolved : \n" + star);
        }

        boolean changed = false;

        final String name = star.getName().toUpperCase();

        if (this.om.addTarget(name, star)) {
          changed = true;
        }

        if (changed) {
          // This method was called by the StarResolverThread (not EDT) :
          SwingUtilities.invokeLater(new Runnable() {

            public void run() {
              // update the target list :
              updateListTargets();

              om.fireObservationChanged();
            }
          });
        }
      }
    }
  }

  /**
   * Update the observation with the form fields if the automatic update flag is enabled.
   * If the observation changed, then fire an observation change event
   */
  private void updateObservation() {
    // check if the automatic update flag is enabled :
    if (this.doAutoUpdateObservation) {
      boolean changed = false;

      // observation :
      changed |= this.om.setInterferometerConfigurationName((String) this.jComboBoxInterferometerConfiguration.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationName((String) this.jComboBoxInstrument.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationStations((String) this.jComboBoxInstrumentConfiguration.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationPoPs(this.jTextPoPs.getText());

      // constraints :
      changed |= this.om.setWhen((Date) this.jDateSpinner.getModel().getValue());
      changed |= this.om.setMinElevation(((Number) this.jFieldMinElev.getValue()).doubleValue());
      changed |= this.om.setNightRestriction(this.jCheckBoxNightLimit.isSelected());

      if (changed) {
        // fire an observation change event :
        this.om.fireObservationChanged();
      }
    }
  }

  /**
   * Update the UI widgets from the given loaded observation
   * 
   * @param observation observation
   */
  private void onLoadObservation(final ObservationSetting observation) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("onLoadObservation :\n" + ObservationManager.toString(observation));
    }
    try {
      // first disable the automatic update observation from field changes :
      this.doAutoUpdateObservation = false;

      // observation :

      // update the interferometer and interferometer configuration :
      final InterferometerConfigurationChoice interferometerChoice = observation.getInterferometerConfiguration();

      final InterferometerConfiguration ic = interferometerChoice.getInterferometerConfiguration();

      if (ic != null) {
        // update the selected interferometer :
        this.jComboBoxInterferometer.setSelectedItem(ic.getInterferometer().getName());
        // update the selected interferometer configuration :
        this.jComboBoxInterferometerConfiguration.setSelectedItem(ic.getName());
      }

      final FocalInstrumentConfigurationChoice instrumentChoice = observation.getInstrumentConfiguration();

      // update the selected instrument :
      this.jComboBoxInstrument.setSelectedItem(instrumentChoice.getName());

      // update the selected instrument configuration (stations) :
      this.jComboBoxInstrumentConfiguration.setSelectedItem(instrumentChoice.getStations());

      // update the selected pops (pops) :
      // note : setText() does not fire a property change event :
      this.jTextPoPs.setText(instrumentChoice.getPops());

      // update the target list :
      updateListTargets();

      // constraints :

      // update the date spinner :
      final XMLGregorianCalendar date = observation.getWhen().getDate();
      if (date != null) {
        this.jDateSpinner.setValue(date.toGregorianCalendar().getTime());
      }

      // update the min elevation :
      this.jFieldMinElev.setValue(interferometerChoice.getMinElevation());

      // update the night restriction :
      this.jCheckBoxNightLimit.setSelected(observation.getWhen().isNightRestriction());

    } finally {
      // restore the automatic update observation from field changes :
      this.doAutoUpdateObservation = true;
    }
  }

  /**
   * Handle the given event on the given observation.
   * Refresh the UI component according to the loaded observation settings
   *
   * @param type event type
   * @param observation observation
   */
  public void onProcess(final ObservationEventType type, final ObservationSetting observation) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + type + "] process IN");
    }
    if (type == ObservationEventType.LOADED) {
      onLoadObservation(observation);
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + type + "] process OUT");
    }
  }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButtonModelEditor;
  private javax.swing.JButton jButtonRemoveTarget;
  private javax.swing.JCheckBox jCheckBoxNightLimit;
  private javax.swing.JComboBox jComboBoxInstrument;
  private javax.swing.JComboBox jComboBoxInstrumentConfiguration;
  private javax.swing.JComboBox jComboBoxInterferometer;
  private javax.swing.JComboBox jComboBoxInterferometerConfiguration;
  private javax.swing.JSpinner jDateSpinner;
  private javax.swing.JFormattedTextField jFieldMinElev;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel3;
  private javax.swing.JLabel jLabel4;
  private javax.swing.JLabel jLabel5;
  private javax.swing.JLabel jLabelConfiguration;
  private javax.swing.JLabel jLabelPeriod;
  private javax.swing.JLabel jLabelPops;
  private javax.swing.JList jListTargets;
  private javax.swing.JPanel jPanelMain;
  private javax.swing.JPanel jPanelOptions;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JFormattedTextField jTextPoPs;
  private fr.jmmc.mcs.astro.star.StarResolverWidget starSearchField;
  // End of variables declaration//GEN-END:variables
}
