/*******************************************************************************
 * JMMC project
 *
 * "@(#) $Id: BasicObservationForm.java,v 1.15 2010-01-08 16:51:17 bourgesl Exp $"
 *
 * History
 * -------
 * $Log: not supported by cvs2svn $
 * Revision 1.14  2010/01/04 15:42:47  bourgesl
 * added missing fields in Target : proper motion, parallax, magnitudes and spectral types (cds raw data)
 *
 * Revision 1.13  2009/12/18 14:50:11  bourgesl
 * check StarResolverWidget notification to process only valid CDS star results
 *
 * Revision 1.12  2009/12/15 16:32:44  bourgesl
 * added user PoP configuration based on PoP indices
 *
 * Revision 1.11  2009/12/11 16:37:32  bourgesl
 * added Pop field in observation form
 *
 * Revision 1.10  2009/12/07 15:17:59  bourgesl
 * Load observation action now refreshes the observation form completely
 *
 * Revision 1.9  2009/12/04 15:38:27  bourgesl
 * Added Save action in the menu bar
 *
 * Revision 1.8  2009/11/24 15:12:09  bourgesl
 * first step to handle delay line limits
 *
 * Revision 1.7  2009/11/17 17:00:28  bourgesl
 * chosen instrument configuration propagated to observation
 *
 * Revision 1.6  2009/11/05 12:59:39  bourgesl
 * first simple source observability (only min elevation condition)
 *
 * Revision 1.5  2009/10/22 15:47:22  bourgesl
 * beginning of observability computation with jSkyCalc
 *
 *
 *
 ******************************************************************************/
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.model.ConfigurationManager;
import fr.jmmc.aspro.model.ObservationListener;
import fr.jmmc.aspro.model.ObservationManager;
import fr.jmmc.aspro.model.oi.FocalInstrumentConfigurationChoice;
import fr.jmmc.aspro.model.oi.InterferometerConfiguration;
import fr.jmmc.aspro.model.oi.InterferometerConfigurationChoice;
import fr.jmmc.aspro.model.oi.ObservationSetting;
import fr.jmmc.aspro.model.oi.Pop;
import fr.jmmc.mcs.astro.star.Star;
import fr.jmmc.mcs.astro.star.StarResolverWidget;
import java.awt.GridBagConstraints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import java.util.logging.Level;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JFormattedTextField;
import javax.swing.JSpinner;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import javax.xml.datatype.XMLGregorianCalendar;

/**
 * This form allows the user to select main observation settings : date, interferometer, configuration, stations and targets ...
 * @author bourgesl
 */
public class BasicObservationForm extends javax.swing.JPanel implements ChangeListener, ActionListener, Observer, ObservationListener {

  /** default serial UID for Serializable interface */
  private static final long serialVersionUID = 1;
  /** Class Name */
  private static final String className_ = "fr.jmmc.aspro.gui.BasicObservationForm";
  /** Class logger */
  private static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
          className_);

  /* members */
  /** observation manager */
  private ObservationManager om = ObservationManager.getInstance();
  /** star resolver widget */
  private StarResolverWidget starSearchField;
  /** flag to enable / disable the automatic update of the observation when any swing component changes */
  private boolean doAutoUpdateObservation = true;

  /** Creates new form BasicObservationForm */
  public BasicObservationForm() {
    initComponents();
    postInit();
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;

    jLabel1 = new javax.swing.JLabel();
    jDateSpinner = new javax.swing.JSpinner();
    jComboBoxInterferometer = new javax.swing.JComboBox();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jComboBoxInstrument = new javax.swing.JComboBox();
    jLabel4 = new javax.swing.JLabel();
    jLabelPeriod = new javax.swing.JLabel();
    jComboBoxInterferometerConfiguration = new javax.swing.JComboBox();
    jButtonRemoveTarget = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    jListTargets = new javax.swing.JList();
    jLabelConfiguration = new javax.swing.JLabel();
    jComboBoxInstrumentConfiguration = new javax.swing.JComboBox();
    jLabelPops = new javax.swing.JLabel();
    jTextPoPs = new JFormattedTextField(getPopsFormatter());

    setLayout(new java.awt.GridBagLayout());

    jLabel1.setText("Date");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);
    add(jLabel1, gridBagConstraints);

    jDateSpinner.setModel(new javax.swing.SpinnerDateModel());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    add(jDateSpinner, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    add(jComboBoxInterferometer, gridBagConstraints);

    jLabel2.setText("Interferometer");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 5;
    gridBagConstraints.ipady = 4;
    add(jLabel2, gridBagConstraints);

    jLabel3.setText("Instrument");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(jLabel3, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    add(jComboBoxInstrument, gridBagConstraints);

    jLabel4.setText("Targets");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 3;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(jLabel4, gridBagConstraints);

    jLabelPeriod.setText("Period");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 3;
    add(jLabelPeriod, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 4;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.ipadx = 2;
    gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
    add(jComboBoxInterferometerConfiguration, gridBagConstraints);

    jButtonRemoveTarget.setText("-");
    jButtonRemoveTarget.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonRemoveTargetActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 3;
    add(jButtonRemoveTarget, gridBagConstraints);

    jScrollPane1.setPreferredSize(new java.awt.Dimension(100, 50));

    jListTargets.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
    jListTargets.setVisibleRowCount(3);
    jScrollPane1.setViewportView(jListTargets);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 3;
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    add(jScrollPane1, gridBagConstraints);

    jLabelConfiguration.setText("Configuration");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(jLabelConfiguration, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 4;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(jComboBoxInstrumentConfiguration, gridBagConstraints);

    jLabelPops.setText("PoPs");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 5;
    gridBagConstraints.gridy = 2;
    add(jLabelPops, gridBagConstraints);

    jTextPoPs.setColumns(4);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 6;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(jTextPoPs, gridBagConstraints);
  }// </editor-fold>//GEN-END:initComponents

  /**
   * Process the remove target action
   * @param evt action event
   */
  private void jButtonRemoveTargetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRemoveTargetActionPerformed
    // remove target action :
    final String name = (String) this.jListTargets.getSelectedValue();
    if (this.om.removeTarget(name)) {
      // update target list :
      updateListTargets();

      this.om.fireObservationChanged();
    }
  }//GEN-LAST:event_jButtonRemoveTargetActionPerformed

  /**
   * Return the Pops custom formatter : number format that accepts null values
   * @return number formatter
   */
  private NumberFormatter getPopsFormatter() {
    final NumberFormatter nf = new NumberFormatter(new DecimalFormat("####")) {

      /** default serial UID for Serializable interface */
      private static final long serialVersionUID = 1;

      /**
       * Hack to allow empty string
       */
      @Override
      public Object stringToValue(String text) throws ParseException {
        if (text == null || text.length() == 0) {
          return null;
        }
        return super.stringToValue(text);
      }
    };
    nf.setValueClass(Integer.class);
    // reject invalid characters (digits only)
    nf.setAllowsInvalid(false);
    nf.setCommitsOnValidEdit(false);
    return nf;
  }

  /**
   * This method is useful to set the models and specific features of initialized swing components.
   * Add the star search field and refresh content of the combo boxes.
   * Finally update the observation according to the form state
   */
  private void postInit() {

    // register this as an observation listener :
    this.om.register(this);

    // add StarResolverWidget :
    final Star star = new Star();
    star.addObserver(this);

    this.starSearchField = new StarResolverWidget(star);

    GridBagConstraints gridBagConstraints = new GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 3;
    gridBagConstraints.gridwidth = 2;
    add(this.starSearchField, gridBagConstraints);

    // update component models :
    this.jDateSpinner.setEditor(new JSpinner.DateEditor(jDateSpinner, "yyyy/MM/dd"));

    this.jComboBoxInterferometer.setModel(new DefaultComboBoxModel(ConfigurationManager.getInstance().getInterferometerNames()));

    // define change listeners :
    this.jDateSpinner.addChangeListener(this);
    this.jComboBoxInterferometer.addActionListener(this);
    this.jComboBoxInterferometerConfiguration.addActionListener(this);
    this.jComboBoxInstrument.addActionListener(this);
    this.jComboBoxInstrumentConfiguration.addActionListener(this);

    this.jTextPoPs.addPropertyChangeListener("value", new PropertyChangeListener() {

      public void propertyChange(final PropertyChangeEvent evt) {
        jTextPoPsPropertyChange(evt);
      }
    });

    updateComboInterferometerConfiguration();
    updateComboInstrument();
    updateComboInstrumentConfiguration();
    updateListTargets();
    checkPops();

    // initial observation synchronization :
    updateObservation();
  }

  /**
   * Refresh the list of interferometer configurations : depends on the chosen interferometer
   */
  private void updateComboInterferometerConfiguration() {
    final Vector<String> v = ConfigurationManager.getInstance().getInterferometerConfigurationNames((String) this.jComboBoxInterferometer.getSelectedItem());
    this.jComboBoxInterferometerConfiguration.setModel(new DefaultComboBoxModel(v));
    final boolean visible = (v.size() > 1);
    this.jLabelPeriod.setVisible(visible);
    this.jComboBoxInterferometerConfiguration.setVisible(visible);
  }

  /**
   * Refresh the list of instruments : depends on the chosen interferometer configuration
   */
  private void updateComboInstrument() {
    final Vector<String> v = ConfigurationManager.getInstance().getInterferometerInstrumentNames((String) this.jComboBoxInterferometerConfiguration.getSelectedItem());
    this.jComboBoxInstrument.setModel(new DefaultComboBoxModel(v));
  }

  /**
   * Refresh the list of instrument configurations : depends on the chosen instrument (also the interferometer configuration)
   */
  private void updateComboInstrumentConfiguration() {
    final Vector<String> v = ConfigurationManager.getInstance().getInstrumentConfigurationNames((String) this.jComboBoxInterferometerConfiguration.getSelectedItem(),
            (String) this.jComboBoxInstrument.getSelectedItem());
    this.jComboBoxInstrumentConfiguration.setModel(new DefaultComboBoxModel(v));
    final boolean visible = (v.size() > 1);
    this.jLabelConfiguration.setVisible(visible);
    this.jComboBoxInstrumentConfiguration.setVisible(visible);
  }

  /**
   * Refresh the target list
   */
  private void updateListTargets() {
    final Vector<String> v = this.om.getTargetNames();
    this.jListTargets.setModel(new DefaultComboBoxModel(v));
    this.jButtonRemoveTarget.setEnabled(!v.isEmpty());
  }

  /**
   * Process any comboBox change event (interferometer, interferometer configuration, instrument, instrument configuration).
   * Refresh the dependent combo boxes and update the observation according to the form state
   * @param e action event
   */
  public void actionPerformed(final ActionEvent e) {
    if (e.getSource() == this.jComboBoxInterferometer) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Interferometer changed : " + this.jComboBoxInterferometer.getSelectedItem());
      }
      updateComboInterferometerConfiguration();
      updateComboInstrument();
      updateComboInstrumentConfiguration();
      checkPops();
    } else if (e.getSource() == this.jComboBoxInterferometerConfiguration) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Interferometer Configuration changed : " + this.jComboBoxInterferometerConfiguration.getSelectedItem());
      }
      updateComboInstrument();
      updateComboInstrumentConfiguration();
    } else if (e.getSource() == this.jComboBoxInstrument) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Instrument changed : " + this.jComboBoxInstrument.getSelectedItem());
      }
      updateComboInstrumentConfiguration();
      checkPops();

    } else if (e.getSource() == this.jComboBoxInstrumentConfiguration) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Instrument Configuration changed : " + this.jComboBoxInstrumentConfiguration.getSelectedItem());
      }
    }
    updateObservation();
  }

  private void checkPops() {
    final boolean hasPops = ConfigurationManager.getInstance().hasPoPs((String) this.jComboBoxInterferometer.getSelectedItem());
    this.jLabelPops.setVisible(hasPops);
    this.jTextPoPs.setVisible(hasPops);
    // reset the pops configuration because it can be invalid because of the chosen instrument
    resetPops();
  }

  /**
   * Process the change event for the PoPs configuration text field.
   * Validates the new input (digits corresponds to valid PoPs indices)
   * @param e action event
   */
  public void jTextPoPsPropertyChange(final PropertyChangeEvent evt) {
    List<Pop> listPoPs = null;

    if (evt.getNewValue() != null) {
      final String popConfig = evt.getNewValue().toString();

      // parse the configuration (instrument = number of channels) + (interferometer = pop indexes [1-5]) :

      listPoPs = ConfigurationManager.getInstance().parseInstrumentPoPs((String) this.jComboBoxInterferometerConfiguration.getSelectedItem(),
              (String) this.jComboBoxInstrument.getSelectedItem(), popConfig);
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("Pops changed = " + evt.getNewValue() + " : " + listPoPs);
    }

    if (listPoPs == null && evt.getNewValue() != null) {
      // invalid, reset the field to empty :
      resetPops();
    }
    // then update the observation :
    updateObservation();
  }

  private void resetPops() {
    // note : setValue() fires a property change event :
    this.jTextPoPs.setValue(null);
  }

  /**
   * Process the date spinner change event.
   * Update the observation according to the form state
   * @param ce change event
   */
  public void stateChanged(final ChangeEvent ce) {
    if (ce.getSource() == this.jDateSpinner) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("Date changed : " + this.jDateSpinner.getModel().getValue());
      }
      updateObservation();
    }
  }

  /**
   * Observer implementation used for the StarResolver.
   * Create a new Target object with the retrieved data from SimBAD and
   * fire an observation change event
   * @param o Observable instance
   * @param arg unused argument
   */
  public void update(final Observable o, final Object arg) {
    if (o instanceof Star) {
      final Star star = (Star) o;

      final Star.Notification notification = (Star.Notification) arg;

      if (notification == Star.Notification.QUERY_COMPLETE) {
        if (logger.isLoggable(Level.FINE)) {
          logger.fine("Star search Field : " + this.starSearchField.getText() + "\n" + star);
        }

        boolean changed = false;

        // concurrent notification protection :
        synchronized (star) {
          final String name = this.starSearchField.getText().toUpperCase();

          if (this.om.addTarget(name, star)) {
            changed = true;
          }
        } // synchronized

        if (changed) {
          SwingUtilities.invokeLater(new Runnable() {

            public void run() {
              // update the target list :
              updateListTargets();

              om.fireObservationChanged();
            }
          });
        }
      }
    }
  }

  /**
   * Update the observation with the form fields.
   * If the observation changed, then fire an observation change event
   */
  private void updateObservation() {
    // check if the automatic update is enabled :
    if (this.doAutoUpdateObservation) {
      boolean changed = false;

      changed |= this.om.setWhen((Date) this.jDateSpinner.getModel().getValue());
      changed |= this.om.setInterferometerConfigurationName((String) this.jComboBoxInterferometerConfiguration.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationName((String) this.jComboBoxInstrument.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationStations((String) this.jComboBoxInstrumentConfiguration.getSelectedItem());
      changed |= this.om.setInstrumentConfigurationPoPs(this.jTextPoPs.getText());

      if (changed) {
        // fire an observation change event :
        this.om.fireObservationChanged();
      }
    }
  }

  /**
   * Handle the given event on the given observation.
   * Refresh the UI component according to the loaded observation settings
   *
   * @param type event type
   * @param observation observation
   */
  public void onProcess(final ObservationEventType type, final ObservationSetting observation) {
    if (type == ObservationEventType.LOADED) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine("loaded occured : " + ObservationManager.toString(observation));
      }

      try {
        // first disable the automatic update observation from field changes :
        this.doAutoUpdateObservation = false;

        // update the date spinner :
        final XMLGregorianCalendar date = observation.getWhen().getDate();
        if (date != null) {
          this.jDateSpinner.setValue(date.toGregorianCalendar().getTime());
        }

        // update the interferometer and interferometer configuration :
        final InterferometerConfigurationChoice interferometerChoice = observation.getInterferometerConfiguration();

        final InterferometerConfiguration ic = interferometerChoice.getInterferometerConfiguration();

        if (ic != null) {
          // update the selected interferometer :
          this.jComboBoxInterferometer.setSelectedItem(ic.getInterferometer().getName());
          // update the selected interferometer configuration :
          this.jComboBoxInterferometerConfiguration.setSelectedItem(ic.getName());
        }

        final FocalInstrumentConfigurationChoice instrumentChoice = observation.getInstrumentConfiguration();

        // update the selected instrument :
        this.jComboBoxInstrument.setSelectedItem(instrumentChoice.getName());

        // update the selected instrument configuration (stations) :
        this.jComboBoxInstrumentConfiguration.setSelectedItem(instrumentChoice.getStations());

        // update the selected pops (pops) :
        // note : setText() does not fire a property change event :
        this.jTextPoPs.setText(instrumentChoice.getPops());

        // update the target list :
        updateListTargets();

      } finally {
        // restore the automatic update observation from field changes :
        this.doAutoUpdateObservation = true;
      }
    }
  }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButtonRemoveTarget;
  private javax.swing.JComboBox jComboBoxInstrument;
  private javax.swing.JComboBox jComboBoxInstrumentConfiguration;
  private javax.swing.JComboBox jComboBoxInterferometer;
  private javax.swing.JComboBox jComboBoxInterferometerConfiguration;
  private javax.swing.JSpinner jDateSpinner;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel3;
  private javax.swing.JLabel jLabel4;
  private javax.swing.JLabel jLabelConfiguration;
  private javax.swing.JLabel jLabelPeriod;
  private javax.swing.JLabel jLabelPops;
  private javax.swing.JList jListTargets;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JFormattedTextField jTextPoPs;
  // End of variables declaration//GEN-END:variables
}
