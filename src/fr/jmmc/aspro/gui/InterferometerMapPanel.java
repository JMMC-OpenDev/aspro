/*******************************************************************************
 * JMMC project
 *
 * "@(#) $Id: InterferometerMapPanel.java,v 1.2 2010-06-08 10:20:41 bourgesl Exp $"
 *
 * History
 * -------
 * $Log: not supported by cvs2svn $
 * Revision 1.1  2010/05/11 12:08:27  bourgesl
 * simple Interferometer Map (stations + baselines) automatically refreshed when the chosen baseline configuration changes
 *
 */
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.AsproConstants;
import fr.jmmc.aspro.gui.action.ExportPDFAction;
import fr.jmmc.aspro.gui.chart.ChartUtils;
import fr.jmmc.aspro.gui.chart.NameLabelGenerator;
import fr.jmmc.aspro.gui.chart.SquareChartPanel;
import fr.jmmc.aspro.gui.chart.SquareXYPlot;
import fr.jmmc.aspro.gui.chart.XYZNameDataSet;
import fr.jmmc.aspro.gui.util.ColorPalette;
import fr.jmmc.aspro.model.InterferometerMapData;
import fr.jmmc.aspro.model.ObservationListener;
import fr.jmmc.aspro.model.ObservationListener.ObservationEventType;
import fr.jmmc.aspro.model.ObservationManager;
import fr.jmmc.aspro.model.oi.ObservationSetting;
import fr.jmmc.aspro.service.InterferometerMapService;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.util.logging.Level;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.encoders.EncoderUtil;
import org.jfree.chart.encoders.ImageFormat;
import org.jfree.chart.event.ChartProgressEvent;
import org.jfree.chart.event.ChartProgressListener;
import org.jfree.chart.labels.ItemLabelAnchor;
import org.jfree.chart.labels.ItemLabelPosition;
import org.jfree.chart.renderer.xy.XYBubbleRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.ui.TextAnchor;

/**
 * This panel presents the interferometer plot (station, base lines ...)
 * @author bourgesl
 */
public class InterferometerMapPanel extends javax.swing.JPanel implements ChartProgressListener,
        ObservationListener {

  /** default serial UID for Serializable interface */
  private static final long serialVersionUID = 1;
  /** Class Name */
  private static final String className_ = "fr.jmmc.aspro.gui.InterferometerMapPanel";
  /** Class logger */
  private static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
          className_);

  /* members */
  /** jFreeChart instance */
  private JFreeChart localJFreeChart;
  /** xy plot instance */
  private SquareXYPlot localXYPlot;
  /* swing */
  /** chart panel */
  private SquareChartPanel chartPanel;

  /**
   * Constructor
   */
  public InterferometerMapPanel() {
    initComponents();

    postInit();

    // register this as an observation listener :
    ObservationManager.getInstance().register(this);
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jPanel1 = new javax.swing.JPanel();
    jButtonPDF = new javax.swing.JButton();

    setLayout(new java.awt.BorderLayout());

    jPanel1.setLayout(new java.awt.BorderLayout());

    jButtonPDF.setIcon(new javax.swing.ImageIcon(getClass().getResource("/fr/jmmc/aspro/gui/icons/icon_pdf.gif"))); // NOI18N
    jButtonPDF.setMargin(new java.awt.Insets(0, 0, 0, 0));
    jButtonPDF.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonPDFActionPerformed(evt);
      }
    });
    jPanel1.add(jButtonPDF, java.awt.BorderLayout.SOUTH);

    add(jPanel1, java.awt.BorderLayout.LINE_START);
  }// </editor-fold>//GEN-END:initComponents

  private void jButtonPDFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPDFActionPerformed

    // set the source with the chart :
    evt.setSource(this.localJFreeChart);

    ExportPDFAction.getInstance().actionPerformed(evt);
}//GEN-LAST:event_jButtonPDFActionPerformed

  /**
   * This method is useful to set the models and specific features of initialized swing components :
   */
  private void postInit() {

    this.localJFreeChart = ChartUtils.createSquareXYLineChart(null, null, true);
    this.localXYPlot = (SquareXYPlot) localJFreeChart.getPlot();

    final XYItemRenderer lineRenderer = this.localXYPlot.getRenderer();

    // Use Bubble Renderer for the first dataset :
    this.localXYPlot.setRenderer(0, new XYBubbleRenderer());

    // Use Bubble Renderer for the second dataset :
    this.localXYPlot.setRenderer(1, lineRenderer);

    // Hide grid lines :
    this.localXYPlot.setDomainGridlinesVisible(false);
    this.localXYPlot.setRangeGridlinesVisible(false);

    // hide axes at [0,0] :
    localXYPlot.setDomainZeroBaselineVisible(false);
    localXYPlot.setRangeZeroBaselineVisible(false);

    final XYItemRenderer localXYItemRenderer = localXYPlot.getRenderer();

    // station labels :
    localXYItemRenderer.setBaseItemLabelGenerator(new NameLabelGenerator());
    localXYItemRenderer.setBasePositiveItemLabelPosition(new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.BOTTOM_RIGHT));
    localXYItemRenderer.setBaseItemLabelsVisible(true);

    // Adjust outline :
    this.localXYPlot.setOutlineStroke(new BasicStroke(1.f));

    // add listener :
    this.localJFreeChart.addProgressListener(this);

    this.chartPanel = new SquareChartPanel(this.localJFreeChart,
            400, 400, /* prefered size */
            200, 200, /* minimum size before scaling */
            1600, 1600, /* maximum size before scaling */
            true, /* use buffer */
            false, /* properties */
            true, /* copy */
            true, /* save */
            true, /* print */
            false, /* zoom */
            false /* tooltips */);

    // zoom options :
    this.chartPanel.setDomainZoomable(AsproConstants.ENABLE_ZOOM);
    this.chartPanel.setRangeZoomable(AsproConstants.ENABLE_ZOOM);

    this.chartPanel.setMinimumSize(new Dimension(650, 500));
    this.add(this.chartPanel);
  }

  /**
   * Handle the changed event to plot the interferometer map synchronously.
   * As this instance is the first observation listener, the plot is first done
   * before other plots / computations are done.
   * @param type event type
   * @param observation observation
   */
  public void onProcess(final ObservationEventType type, final ObservationSetting observation) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + type + "] process IN");
    }
    switch (type) {
      case CHANGED:
        this.plot(observation);
        break;
      default:
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + type + "] process OUT");
    }
  }

  /**
   * Plot the interferometer map synchronously.
   * This code must be executed by the Swing Event Dispatcher thread (EDT)
   * @param observation observation data to use
   */
  protected void plot(final ObservationSetting observation) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("plot : " + ObservationManager.toString(observation));
    }

    final long start = System.nanoTime();

    final InterferometerMapData mapData = InterferometerMapService.compute(observation);

    ChartUtils.clearTextSubTitle(localJFreeChart);

    // title :
    final StringBuilder title = new StringBuilder(observation.getInterferometerConfiguration().getName());
    title.append(" - ").append(observation.getInstrumentConfiguration().getStations());

    ChartUtils.addSubtitle(localJFreeChart, title.toString());

    // computed data are valid :
    updateChart(mapData);

    // update theme at end :
    ChartUtilities.applyCurrentTheme(localJFreeChart);

    this.localXYPlot.setBackgroundPaint(Color.WHITE);

    // test to save plot to PNG :
    if (false) {
      savePlot();
    }

    if (logger.isLoggable(Level.INFO)) {
      logger.info("plot : duration = " + 1e-6d * (System.nanoTime() - start) + " ms.");
    }
  }

  /**
   * Test code to save plot to PNG (can be used in tooltips) :
   */
  private void savePlot() {
    try {
      final JFreeChart chart = (JFreeChart) this.localJFreeChart.clone();

      chart.clearSubtitles();

      ValueAxis axis = chart.getXYPlot().getDomainAxis();
      axis.setTickLabelsVisible(false);
      axis.setTickMarksVisible(false);

      axis = chart.getXYPlot().getRangeAxis();
      axis.setTickLabelsVisible(false);
      axis.setTickMarksVisible(false);

      /* Generating temporary file */
      final File outFile = File.createTempFile("mapPlot", ".png");

      final FileOutputStream out = new FileOutputStream(outFile);

      // Keep a square area in both image and chart :
      final BufferedImage bufferedImage = chart.createBufferedImage(200, 200,
              400, 400, null);

      EncoderUtil.writeBufferedImage(bufferedImage, ImageFormat.PNG, out);
    } catch (Exception e) {
      logger.log(Level.SEVERE, "failure ", e);
    }
  }

  /**
   * Update the datasets
   * @param mapData map data
   */
  private void updateChart(final InterferometerMapData mapData) {

    // renderer for base lines :
    final XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) this.localXYPlot.getRenderer(1);

    // reset colors :
    renderer.clearSeriesPaints(false);
    // side effect with chart theme :
    renderer.setAutoPopulateSeriesPaint(false);

    final ColorPalette palette = ColorPalette.getDefaultColorPalette();

    // define bounds to the maximum value + 10% (before setDataset) :
    this.localXYPlot.defineBounds(mapData.getMaxXY() * 1.10d);

    // first plot stations :
    final XYZNameDataSet dataset1 = new XYZNameDataSet();

    dataset1.addSeries("Stations", new double[][]{mapData.getStationX(), mapData.getStationY(), mapData.getDiameter()}, mapData.getStationName());

    // set the first data set :
    this.localXYPlot.setDataset(dataset1);

    // baselines :
    final XYSeriesCollection dataset2 = new XYSeriesCollection();

    final String[] blName = mapData.getBaselineName();
    final double[] blX1 = mapData.getBaselineStationX1();
    final double[] blY1 = mapData.getBaselineStationY1();
    final double[] blX2 = mapData.getBaselineStationX2();
    final double[] blY2 = mapData.getBaselineStationY2();

    int n = 0;
    XYSeries xySeriesBL;
    for (int i = 0, len = blName.length; i < len; i++) {
      xySeriesBL = new XYSeries(blName[i], false);
      xySeriesBL.setNotify(false);

      // first station :
      xySeriesBL.add(blX1[i], blY1[i]);

      // second station :
      xySeriesBL.add(blX2[i], blY2[i]);

      // add an invalid point to break the line between the 2 segments :
      xySeriesBL.add(Double.NaN, Double.NaN);

      xySeriesBL.setNotify(true);
      dataset2.addSeries(xySeriesBL);

      // color :
      renderer.setSeriesPaint(n, palette.getColor(n), false);

      n++;
    }

    // set the second data set :
    this.localXYPlot.setDataset(1, dataset2);
  }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButtonPDF;
  private javax.swing.JPanel jPanel1;
  // End of variables declaration//GEN-END:variables
  /** drawing started time value */
  private long lastTime = 0l;

  public void chartProgress(final ChartProgressEvent event) {
    if (logger.isLoggable(Level.FINE)) {
      switch (event.getType()) {
        case ChartProgressEvent.DRAWING_STARTED:
          this.lastTime = System.nanoTime();
          break;
        case ChartProgressEvent.DRAWING_FINISHED:
          logger.fine("Drawing chart time : " + 1e-6d * (System.nanoTime() - this.lastTime) + " ms.");
          this.lastTime = 0l;
          break;
        default:
      }
    }
  }
}
