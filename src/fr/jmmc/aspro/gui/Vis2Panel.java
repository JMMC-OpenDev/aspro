/*******************************************************************************
 * JMMC project ( http://www.jmmc.fr ) - Copyright (C) CNRS.
 ******************************************************************************/
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.AsproConstants;
import fr.jmmc.aspro.gui.action.ExportPDFAction;
import fr.jmmc.aspro.gui.chart.BoundedNumberAxis;
import fr.jmmc.aspro.gui.chart.ChartUtils;
import fr.jmmc.aspro.gui.chart.PDFOptions;
import fr.jmmc.aspro.gui.chart.PDFOptions.Orientation;
import fr.jmmc.aspro.gui.chart.PDFOptions.PageSize;
import fr.jmmc.aspro.gui.chart.ZoomEvent;
import fr.jmmc.aspro.gui.chart.ZoomEventListener;
import fr.jmmc.aspro.model.event.OIFitsEvent;
import fr.jmmc.aspro.model.event.ObservationEvent;
import fr.jmmc.aspro.model.event.ObservationListener;
import fr.jmmc.jmal.image.ColorModels;
import fr.jmmc.jmal.image.ImageUtils;
import fr.jmmc.oitools.model.OIArray;
import fr.jmmc.oitools.model.OIFitsFile;
import fr.jmmc.oitools.model.OIVis2;
import java.awt.Color;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.awt.image.IndexColorModel;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.logging.Level;

import org.jfree.chart.ChartPanel;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYTextAnnotation;
import org.jfree.chart.event.ChartProgressEvent;
import org.jfree.chart.event.ChartProgressListener;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYErrorRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.Range;
import org.jfree.data.xy.YIntervalSeries;
import org.jfree.data.xy.YIntervalSeriesCollection;
import org.jfree.ui.Layer;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;

/**
 * This panel presents the interferometer plot (station, base lines ...)
 * @author bourgesl
 */
public final class Vis2Panel extends javax.swing.JPanel implements ChartProgressListener, ZoomEventListener,
                                                                   ObservationListener, PDFExportable {

  /** default serial UID for Serializable interface */
  private static final long serialVersionUID = 1;
  /** Class Name */
  private static final String className_ = Vis2Panel.class.getName();
  /** Class logger */
  private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
          className_);
  /** default color model (aspro - Rainbow) */
  private final static IndexColorModel RAINBOW_COLOR_MODEL = ColorModels.getColorModel("Rainbow");
  /** scaling factor to Mega Lambda for U,V points */
  private final static double MEGA_LAMBDA_SCALE = 1e-6;
  /** flag to use square instead of cross to reprensent points */
  private final static boolean USE_SQUARE = true;
  /** data margin in percents */
  private final static double MARGIN_PERCENTS = 5d / 100d;
  /** double formatter for wave lengths */
  private final static NumberFormat df4 = new DecimalFormat("0.000#");

  /* members */
  /** jFreeChart instance */
  private JFreeChart chart;
  /** xy plot instance */
  private XYPlot xyPlot;
  /** JMMC annotation */
  private XYTextAnnotation aJMMC = null;
  /** uv coordinates scaling factor */
  private double uvPlotScalingFactor = MEGA_LAMBDA_SCALE;
  /* plot data */
  /** current oifits file to track changes */
  private OIFitsFile oiFitsFile = null;
  /* swing */
  /** chart panel */
  private ChartPanel chartPanel;

  /**
   * Constructor
   */
  public Vis2Panel() {
    initComponents();

    postInit();
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    setLayout(new java.awt.BorderLayout());
  }// </editor-fold>//GEN-END:initComponents

  /**
   * Export the chart component as a PDF document
   */
  @Override
  public void performPDFAction() {
    ExportPDFAction.exportPDF(this);
  }

  /**
   * Return the PDF default file name
   * [Vis2_<TARGET>_<INSTRUMENT>_<CONFIGURATION>_<DATE>]
   * @return PDF default file name
   */
  @Override
  public String getPDFDefaultFileName() {
    if (this.oiFitsFile != null) {
      final StringBuilder sb = new StringBuilder(32).append("Vis2_");

      final String targetName = this.oiFitsFile.getOiTarget().getTarget()[0];
      final String altName = targetName.replaceAll(AsproConstants.REGEXP_INVALID_TEXT_CHARS, "_");

      sb.append(altName).append('_');

      final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];

      final String arrayName = vis2.getArrName();
      final String insName = vis2.getInsName();

      sb.append(insName).append('_');

      final OIArray array = this.oiFitsFile.getOiArray(arrayName);
      for (String station : array.getStaName()) {
        sb.append(station).append('-');
      }
      sb.deleteCharAt(sb.length() - 1);
      sb.append('_');

      final String dateObs = vis2.getDateObs();

      sb.append(dateObs);

      sb.append('.').append(PDF_EXT);

      return sb.toString();
    }
    return null;
  }

  /**
   * Return the PDF options
   * @return PDF options
   */
  @Override
  public PDFOptions getPDFOptions() {
    return new PDFOptions(PageSize.A3, Orientation.Landscape);
  }

  /**
   * Return the chart to export as a PDF document
   * @return chart
   */
  @Override
  public JFreeChart prepareChart() {
    return this.chart;
  }

  /**
   * Callback indicating the chart was processed by the PDF engine
   */
  @Override
  public void postPDFExport() {
    // no-op
  }

  /**
   * This method is useful to set the models and specific features of initialized swing components :
   */
  private void postInit() {
    // use white color when the chart panel is hidden (nothing to plot)
    this.setBackground(Color.WHITE);

    this.chart = ChartUtils.createScatterPlot("", "UV radius (M\u03BB)", "VÂ²", null, PlotOrientation.VERTICAL, false, false, false);
    this.xyPlot = this.chart.getXYPlot();

    // enlarge right margin to have last displayed hour (00:00)
    this.xyPlot.setInsets(new RectangleInsets(2d, 10d, 2d, 20d));

    /*
    xyPlot.setDomainCrosshairLockedOnData(true);
    xyPlot.setDomainCrosshairVisible(true);
    
    xyPlot.setRangeCrosshairLockedOnData(true);
    xyPlot.setRangeCrosshairVisible(true);
     */

    xyPlot.setDomainGridlinePaint(Color.LIGHT_GRAY);
    xyPlot.setRangeGridlinePaint(Color.LIGHT_GRAY);

    // use custom units :
    xyPlot.getRangeAxis().setStandardTickUnits(ChartUtils.createScientificTickUnits());
    xyPlot.getDomainAxis().setStandardTickUnits(ChartUtils.createScientificTickUnits());

    final XYErrorRenderer renderer = (XYErrorRenderer) xyPlot.getRenderer();

    // force to use the base shape :
    renderer.setAutoPopulateSeriesShape(false);
    renderer.setBaseShape(getPointShape());

    // reset colors :
    renderer.setAutoPopulateSeriesPaint(false);
    renderer.clearSeriesPaints(false);

    // error color:
    renderer.setErrorPaint(new Color(192, 192, 192, 128));

    // add listener :
    this.chart.addProgressListener(this);
    this.chartPanel = ChartUtils.createChartPanel(this.chart);

    // zoom options :
    this.chartPanel.setDomainZoomable(AsproConstants.ENABLE_ZOOM);
    this.chartPanel.setRangeZoomable(AsproConstants.ENABLE_ZOOM);

    // enable mouse wheel:
    this.chartPanel.setMouseWheelEnabled(true);

    this.add(this.chartPanel);
  }

  /**
   * Handle the changed event to plot the vis2 plot synchronously.   
   * @param event event
   */
  @Override
  public void onProcess(final ObservationEvent event) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + event.getType() + "] process IN");
    }
    switch (event.getType()) {
      case REFRESH:
        // reset content :
        this.plot(null);
        break;
      case OIFITS_DONE:
        this.plot(((OIFitsEvent) event).getOIFitsFile());
        break;
      default:
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + event.getType() + "] process OUT");
    }
  }

  /**
   * Plot the squarred visibilities of the generated file synchronously.
   * This code must be executed by the Swing Event Dispatcher thread (EDT)
   * @param oiFitsFile OIFits file to use
   */
  private void plot(final OIFitsFile oiFitsFile) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("plot : " + oiFitsFile);
    }

    // refresh the plot :
    this.oiFitsFile = oiFitsFile;

    if (logger.isLoggable(Level.FINE)) {
      logger.fine("plot : refresh");
    }

    final long start = System.nanoTime();

    this.updatePlot();

    // update theme at end :
    ChartUtilities.applyCurrentTheme(this.chart);

    this.xyPlot.setBackgroundPaint(Color.WHITE);
    this.xyPlot.setDomainGridlinePaint(Color.LIGHT_GRAY);
    this.xyPlot.setRangeGridlinePaint(Color.LIGHT_GRAY);

    if (logger.isLoggable(Level.INFO)) {
      logger.info("plot : duration = " + 1e-6d * (System.nanoTime() - start) + " ms.");
    }
  }

  /**
   * Refresh the plot using chart data.
   * This code is executed by the Swing Event Dispatcher thread (EDT)
   */
  private void updatePlot() {

    // title :
    ChartUtils.clearTextSubTitle(this.chart);

    if (this.oiFitsFile == null) {
      this.xyPlot.setDataset(null);
      this.chartPanel.setVisible(false);
      return;
    }

    this.chartPanel.setVisible(true);

    final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];
    final String arrayName = vis2.getArrName();
    final String insName = vis2.getInsName();
    final OIArray array = this.oiFitsFile.getOiArray(arrayName);

    final float[] effWaves = vis2.getOiWavelength().getEffWave();
    final double wlMin = 1e6d * effWaves[0];
    final double wlMax = 1e6d * effWaves[effWaves.length - 1];

    final StringBuilder sb = new StringBuilder(32);
    sb.append(arrayName).append(" - ");
    sb.append(insName);
    sb.append(" [").append(df4.format(wlMin)).append(" \u00B5m - ").append(df4.format(wlMax)).append(" \u00B5m] - ");

    for (String station : array.getStaName()) {
      sb.append(station).append(' ');
    }
    ChartUtils.addSubtitle(this.chart, sb.toString());

    ChartUtils.addSubtitle(this.chart, "Source : " + this.oiFitsFile.getOiTarget().getTarget()[0]);

    // date :
    ChartUtils.addSubtitle(this.chart, "Day : " + vis2.getDateObs());

    // change the scaling factor ?
    setUvPlotScalingFactor(MEGA_LAMBDA_SCALE);

    // computed data are valid :
    updateChart();
  }

  /**
   * Update the datasets
   */
  private void updateChart() {
    final XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) this.xyPlot.getRenderer();

    // try to fill with squared visibilities
    final YIntervalSeriesCollection dataset = new YIntervalSeriesCollection();
    YIntervalSeries yIntervalSeries = null;

    final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];

    final int nRows = vis2.getNbRows();
    final int nWaves = vis2.getNWave();

    // Prepare palette
    final Color[] colors = new Color[nWaves];
    
    final IndexColorModel colorModel = RAINBOW_COLOR_MODEL;

    final int iMaxColor = colorModel.getMapSize() - 1;

    final float factor = ((float) iMaxColor) / nWaves;
    float value;

    final int alphaMask = Math.round(255 * 0.8f) << 24;

    for (int i = 0; i < nWaves; i++) {
      // invert palette to have (VIOLET - BLUE - GREEN - RED) ie color spectrum:
      value = iMaxColor - factor * i;
      
      colors[i] = new Color(ImageUtils.getRGB(colorModel, iMaxColor, value, alphaMask), true);
    }

    final double[][] vis2Data = vis2.getVis2Data();
    final double[][] vis2Err = vis2.getVis2Err();

    // compute spatial frequencies:
    final double[][] spatialFreq = vis2.getSpatialFreq();

    double minX = Double.POSITIVE_INFINITY;
    double maxX = 0d;
    double minY = 0d;
    double maxY = 1d;
    double x, y, err;

    for (int j = 0; j < nWaves; j++) {
      
      // 1 color per spectral channel (i.e. per XYSeries) :
      yIntervalSeries = new YIntervalSeries("VIS2 W" + j, false, true);
      yIntervalSeries.setNotify(false);

      for (int i = 0; i < nRows; i++) {
        
        x = toUVPlotScale(spatialFreq[i][j]);
        y = vis2Data[i][j];
        err = vis2Err[i][j];

        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }

        yIntervalSeries.add(x, y, y - err, y + err);
      }

      dataset.addSeries(yIntervalSeries);

      renderer.setSeriesPaint(j, colors[j], false);
    }

    this.xyPlot.setDataset(dataset);

    // margin:
    final double marginX = (maxX - minX) * MARGIN_PERCENTS;
    minX -= marginX;
    maxX += marginX;

    final double marginY = (maxY - minY) * MARGIN_PERCENTS;
    minY -= marginY;
    maxY += marginY;

    BoundedNumberAxis axis;

    axis = (BoundedNumberAxis) this.xyPlot.getDomainAxis();
    axis.setBounds(new Range(minX, maxX));
    axis.setRange(minX, maxX);

    axis = (BoundedNumberAxis) this.xyPlot.getRangeAxis();
    axis.setBounds(new Range(minY, maxY));
    axis.setRange(minY, maxY);

    // annotation JMMC (moving position) :
    this.xyPlot.getRenderer(0).removeAnnotations();
    if (this.aJMMC == null) {
      this.aJMMC = ChartUtils.createXYTextAnnotation(AsproConstants.JMMC_ANNOTATION, 0.5, 0.5);
      this.aJMMC.setTextAnchor(TextAnchor.BOTTOM_RIGHT);
      this.aJMMC.setPaint(Color.DARK_GRAY);
    } else {
      this.aJMMC.setX(0.5);
      this.aJMMC.setY(0.5);
    }
    this.xyPlot.getRenderer(0).addAnnotation(this.aJMMC, Layer.BACKGROUND);
  }

  /**
   * Process the zoom event to refresh the model UV map according to the new coordinates
   * @param ze zoom event
   */
  @Override
  public void chartChanged(final ZoomEvent ze) {
    // reset bounds between -0.1 and 1.1 :
    // @todo check if this code can be removed setting constraints on another place
    this.xyPlot.getDomainAxis(0).setLowerBound(-0.1);
    this.xyPlot.getDomainAxis(0).setUpperBound(1.1);

    if (this.aJMMC != null) {
      this.xyPlot.getRenderer(0).removeAnnotations();
      this.aJMMC.setX(ze.getDomainUpperBound());
      this.aJMMC.setY(ze.getRangeLowerBound());

      this.xyPlot.getRenderer(0).addAnnotation(this.aJMMC, Layer.BACKGROUND);
    }
  }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  /** drawing started time value */
  private long lastTime = 0l;

  /**
   * Handle the chart progress event to log the chart rendering delay
   * @param event chart progress event
   */
  @Override
  public void chartProgress(final ChartProgressEvent event) {
    // TODO: use fine level when stable:
    if (logger.isLoggable(Level.INFO)) {
      switch (event.getType()) {
        case ChartProgressEvent.DRAWING_STARTED:
          this.lastTime = System.nanoTime();
          break;
        case ChartProgressEvent.DRAWING_FINISHED:
          logger.info("Drawing chart time : " + 1e-6d * (System.nanoTime() - this.lastTime) + " ms.");
          this.lastTime = 0l;
          break;
        default:
      }
    }
  }

  /**
   * Define the uv scaling factor
   * @param uvPlotScalingFactor new value
   */
  private void setUvPlotScalingFactor(final double uvPlotScalingFactor) {
    this.uvPlotScalingFactor = uvPlotScalingFactor;
  }

  /**
   * Convert the given value (u or v) to the plot scale
   * @param value u or v coordinate in rad-1
   * @return u or v coordinate in the plot unit
   */
  private double toUVPlotScale(final double value) {
    return this.uvPlotScalingFactor * value;
  }

  /**
   * Convert the given plot value (u or v) to the standard unit (rad-1)
   * @param value u or v coordinate in the plot unit
   * @return u or v coordinate in rad-1
   */
  private double fromUVPlotScale(final double value) {
    return value / this.uvPlotScalingFactor;
  }

  /**
   * Return the shape used to represent points on the plot
   * @return shape
   */
  private static Shape getPointShape() {

    final float size = 3f;

    if (USE_SQUARE) {
      return new Rectangle2D.Double(-size, -size, 2 * size, 2 * size);
    }

    final GeneralPath path = new GeneralPath();

    path.moveTo(-size, 0f);
    path.lineTo(size, 0f);

    path.moveTo(0f, -size);
    path.lineTo(0f, size);

    return path;
  }
}
