/*******************************************************************************
 * JMMC project ( http://www.jmmc.fr ) - Copyright (C) CNRS.
 ******************************************************************************/
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.AsproConstants;
import fr.jmmc.aspro.gui.action.ExportPDFAction;
import fr.jmmc.aspro.gui.chart.BoundedNumberAxis;
import fr.jmmc.aspro.gui.chart.ChartUtils;
import fr.jmmc.aspro.gui.chart.PDFOptions;
import fr.jmmc.aspro.gui.chart.PDFOptions.Orientation;
import fr.jmmc.aspro.gui.chart.PDFOptions.PageSize;
import fr.jmmc.aspro.model.event.OIFitsEvent;
import fr.jmmc.aspro.model.event.ObservationEvent;
import fr.jmmc.aspro.model.event.ObservationListener;
import fr.jmmc.jmal.image.ColorModels;
import fr.jmmc.jmal.image.ImageUtils;
import fr.jmmc.oitools.model.OIArray;
import fr.jmmc.oitools.model.OIFitsFile;
import fr.jmmc.oitools.model.OIVis2;
import java.awt.Color;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.awt.image.IndexColorModel;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.logging.Level;

import org.jfree.chart.ChartPanel;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYTextAnnotation;
import org.jfree.chart.event.ChartProgressEvent;
import org.jfree.chart.event.ChartProgressListener;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYErrorRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.Range;
import org.jfree.data.xy.YIntervalSeries;
import org.jfree.data.xy.YIntervalSeriesCollection;
import org.jfree.ui.Layer;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;

/**
 * This panel presents the interferometer plot (station, base lines ...)
 * @author bourgesl
 */
public final class Vis2Panel extends javax.swing.JPanel implements ChartProgressListener,
                                                                   ObservationListener, PDFExportable {

  /** default serial UID for Serializable interface */
  private static final long serialVersionUID = 1;
  /** Class logger */
  private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(Vis2Panel.class.getName());
  /** default color model (aspro - Rainbow) */
  private final static IndexColorModel RAINBOW_COLOR_MODEL = ColorModels.getColorModel("Rainbow");
  /** scaling factor to Mega Lambda for U,V points */
  private final static double MEGA_LAMBDA_SCALE = 1e-6;
  /** data margin in percents */
  private final static double MARGIN_PERCENTS = 5d / 100d;
  /** double formatter for wave lengths */
  private final static NumberFormat df4 = new DecimalFormat("0.000#");

  /* members */
  /** jFreeChart instance */
  private JFreeChart chart;
  /** xy plot instance */
  private XYPlot xyPlot;
  /** JMMC annotation */
  private XYTextAnnotation aJMMC = null;
  /** uv coordinates scaling factor */
  private double uvPlotScalingFactor = MEGA_LAMBDA_SCALE;
  /* plot data */
  /** current oifits file to track changes */
  private OIFitsFile oiFitsFile = null;
  /* swing */
  /** chart panel */
  private ChartPanel chartPanel;

  /**
   * Constructor
   */
  public Vis2Panel() {
    initComponents();

    postInit();
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelCenter = new javax.swing.JPanel();
        jLabelMessage = new javax.swing.JLabel();

        setLayout(new java.awt.BorderLayout());

        jPanelCenter.setBackground(new java.awt.Color(255, 255, 255));
        jPanelCenter.setLayout(new javax.swing.BoxLayout(jPanelCenter, javax.swing.BoxLayout.Y_AXIS));

        jLabelMessage.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelMessage.setText("LABEL");
        jLabelMessage.setAlignmentX(0.5F);
        jPanelCenter.add(jLabelMessage);

        add(jPanelCenter, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

  /**
   * Export the chart component as a PDF document
   */
  @Override
  public void performPDFAction() {
    // if no OIFits data, discard action:
    if (this.oiFitsFile != null) {
      ExportPDFAction.exportPDF(this);
    }
  }

  /**
   * Return the PDF default file name
   * [Vis2_<TARGET>_<INSTRUMENT>_<CONFIGURATION>_<DATE>]
   * @return PDF default file name
   */
  @Override
  public String getPDFDefaultFileName() {
    if (this.oiFitsFile != null) {
      final StringBuilder sb = new StringBuilder(32).append("Vis2_");

      final String targetName = this.oiFitsFile.getOiTarget().getTarget()[0];
      final String altName = targetName.replaceAll(AsproConstants.REGEXP_INVALID_TEXT_CHARS, "_");

      sb.append(altName).append('_');

      final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];

      final String arrayName = vis2.getArrName();
      final String insName = vis2.getInsName();

      sb.append(insName).append('_');

      final OIArray array = this.oiFitsFile.getOiArray(arrayName);
      for (String station : array.getStaName()) {
        sb.append(station).append('-');
      }
      sb.deleteCharAt(sb.length() - 1);
      sb.append('_');

      final String dateObs = vis2.getDateObs();

      sb.append(dateObs);

      sb.append('.').append(PDF_EXT);

      return sb.toString();
    }
    return null;
  }

  /**
   * Return the PDF options
   * @return PDF options
   */
  @Override
  public PDFOptions getPDFOptions() {
    return new PDFOptions(PageSize.A3, Orientation.Landscape);
  }

  /**
   * Return the chart to export as a PDF document
   * @return chart
   */
  @Override
  public JFreeChart prepareChart() {
    return this.chart;
  }

  /**
   * Callback indicating the chart was processed by the PDF engine
   */
  @Override
  public void postPDFExport() {
    // no-op
  }

  /**
   * This method is useful to set the models and specific features of initialized swing components :
   */
  private void postInit() {
    this.chart = ChartUtils.createScatterPlot("", "UV radius (M\u03BB)", "VÂ²", null, PlotOrientation.VERTICAL, false, false, false);
    this.xyPlot = this.chart.getXYPlot();

    // enlarge right margin to have last displayed hour (00:00)
    this.xyPlot.setInsets(new RectangleInsets(2d, 10d, 2d, 20d));

    /*
    xyPlot.setDomainCrosshairLockedOnData(true);
    xyPlot.setDomainCrosshairVisible(true);
    
    xyPlot.setRangeCrosshairLockedOnData(true);
    xyPlot.setRangeCrosshairVisible(true);
     */

    this.xyPlot.setDomainGridlinePaint(Color.LIGHT_GRAY);
    this.xyPlot.setRangeGridlinePaint(Color.LIGHT_GRAY);

    // use custom units :
    this.xyPlot.getRangeAxis().setStandardTickUnits(ChartUtils.createScientificTickUnits());
    this.xyPlot.getDomainAxis().setStandardTickUnits(ChartUtils.createScientificTickUnits());

    final XYErrorRenderer renderer = (XYErrorRenderer) xyPlot.getRenderer();

    // force to use the base shape :
    renderer.setAutoPopulateSeriesShape(false);

    // reset colors :
    renderer.setAutoPopulateSeriesPaint(false);
    renderer.clearSeriesPaints(false);

    // error color:
    renderer.setCapLength(0d);
    renderer.setErrorPaint(new Color(192, 192, 192, 128));
    
    this.aJMMC = ChartUtils.createXYTextAnnotation(AsproConstants.JMMC_ANNOTATION, 0, 0);
    this.aJMMC.setTextAnchor(TextAnchor.BOTTOM_RIGHT);
    this.aJMMC.setPaint(Color.DARK_GRAY);
    this.xyPlot.getRenderer().addAnnotation(this.aJMMC, Layer.BACKGROUND);

    // add listener :
    this.chart.addProgressListener(this);
    this.chartPanel = ChartUtils.createChartPanel(this.chart);

    // zoom options :
    this.chartPanel.setDomainZoomable(AsproConstants.ENABLE_ZOOM);
    this.chartPanel.setRangeZoomable(AsproConstants.ENABLE_ZOOM);

    // enable mouse wheel:
    this.chartPanel.setMouseWheelEnabled(true);
    
    this.jPanelCenter.add(this.chartPanel);
  }

  /**t
   * Handle the changed event to plot the vis2 plot synchronously.   
   * @param event event
   */
  @Override
  public void onProcess(final ObservationEvent event) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + event.getType() + "] process IN");
    }
    switch (event.getType()) {
      case OIFITS_DONE:
        if (event instanceof OIFitsEvent) {
          this.plot(((OIFitsEvent) event).getOIFitsFile());
        }
        break;
      default:
    }
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("event [" + event.getType() + "] process OUT");
    }
  }

  /**
   * Plot the squarred visibilities of the generated file synchronously.
   * This code must be executed by the Swing Event Dispatcher thread (EDT)
   * @param oiFitsFile OIFits file to use
   */
  private void plot(final OIFitsFile oiFitsFile) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("plot : " + oiFitsFile);
    }

    // refresh the plot :
    this.oiFitsFile = oiFitsFile;
    
    if (logger.isLoggable(Level.FINE)) {
      logger.fine("plot : refresh");
    }

    final long start = System.nanoTime();

    this.updatePlot();

    if (logger.isLoggable(Level.INFO)) {
      logger.info("plot : duration = " + 1e-6d * (System.nanoTime() - start) + " ms.");
    }
  }

  /**
   * Reset plot
   */
  private void resetPlot() {
    // reset title:
    ChartUtils.clearTextSubTitle(this.chart);

    // reset dataset:
    this.xyPlot.setDataset(null);
  }
  
  /**
   * Show message or plot
   * @param show flag to indicate to show label
   */
  private void showMessage(final boolean show) {
    this.jLabelMessage.setVisible(show);
    this.chartPanel.setVisible(!show);
  }

  /**
   * Refresh the plot using chart data.
   * This code is executed by the Swing Event Dispatcher thread (EDT)
   */
  private void updatePlot() {

    if (this.oiFitsFile == null) {
      resetPlot();
      this.jLabelMessage.setText("No VIS2 data available: the target is not observable or multiple configurations are selected.");
      showMessage(true);
      return;
    }

    final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];
    final String arrayName = vis2.getArrName();
    final String insName = vis2.getInsName();
    final OIArray array = this.oiFitsFile.getOiArray(arrayName);

    final float[] effWaves = vis2.getOiWavelength().getEffWave();
    final double wlMin = 1e6d * effWaves[0];
    final double wlMax = 1e6d * effWaves[effWaves.length - 1];

    // title :
    ChartUtils.clearTextSubTitle(this.chart);

    final StringBuilder sb = new StringBuilder(32);
    sb.append(arrayName).append(" - ");
    sb.append(insName);
    sb.append(" [").append(df4.format(wlMin)).append(" \u00B5m - ").append(df4.format(wlMax)).append(" \u00B5m] - ");

    for (String station : array.getStaName()) {
      sb.append(station).append(' ');
    }
    
    ChartUtils.addSubtitle(this.chart, sb.toString());

    ChartUtils.addSubtitle(this.chart, "Source : " + this.oiFitsFile.getOiTarget().getTarget()[0]);

    // date :
    ChartUtils.addSubtitle(this.chart, "Day : " + vis2.getDateObs());

    // change the scaling factor ?
    setUvPlotScalingFactor(MEGA_LAMBDA_SCALE);

    // computed data are valid :
    final boolean hasData = updateChart();

    if (hasData) {
      // update theme at end :
      ChartUtilities.applyCurrentTheme(this.chart);

      this.xyPlot.setBackgroundPaint(Color.WHITE);
      this.xyPlot.setDomainGridlinePaint(Color.LIGHT_GRAY);
      this.xyPlot.setRangeGridlinePaint(Color.LIGHT_GRAY);
    } else {
      this.jLabelMessage.setText("No VIS2 data available: the target has no model.");
    }
    
    showMessage(!hasData);
  }

  /**
   * Update the datasets
   * @return true if vis2 has data to plot
   */
  private boolean updateChart() {
    boolean hasData = false;
    
    final XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) this.xyPlot.getRenderer();

    // try to fill with squared visibilities
    final YIntervalSeriesCollection dataset = new YIntervalSeriesCollection();
    YIntervalSeries yIntervalSeries = null;

    final OIVis2 vis2 = this.oiFitsFile.getOiVis2()[0];

    final int nRows = vis2.getNbRows();
    final int nWaves = vis2.getNWave();

    // Prepare palette
    final Color[] colors = new Color[nWaves];
    
    final IndexColorModel colorModel = RAINBOW_COLOR_MODEL;

    final int iMaxColor = colorModel.getMapSize() - 1;

    final float factor = ((float) iMaxColor) / nWaves;
    float value;

    final int alphaMask = Math.round(255 * 0.8f) << 24;

    for (int i = 0; i < nWaves; i++) {
      // invert palette to have (VIOLET - BLUE - GREEN - RED) ie color spectrum:
      value = iMaxColor - factor * i;
      
      colors[i] = new Color(ImageUtils.getRGB(colorModel, iMaxColor, value, alphaMask), true);
    }

    final double[][] vis2Data = vis2.getVis2Data();
    final double[][] vis2Err = vis2.getVis2Err();

    // compute spatial frequencies:
    final double[][] spatialFreq = vis2.getSpatialFreq();

    boolean hasErr = false;
    double minX = Double.POSITIVE_INFINITY;
    double maxX = 0d;
    double minY = 0d;
    double maxY = 1d;
    double x, y, err;

    for (int j = 0; j < nWaves; j++) {
      
      // 1 color per spectral channel (i.e. per XYSeries) :
      yIntervalSeries = new YIntervalSeries("VIS2 W" + j, false, true);
      yIntervalSeries.setNotify(false);

      for (int i = 0; i < nRows; i++) {
        
        x = toUVPlotScale(spatialFreq[i][j]);
        y = vis2Data[i][j];
        err = vis2Err[i][j];
        
        if (!Double.isNaN(y)) {
          hasData = true;
          
          if (x < minX) {
            minX = x;
          }
          if (x > maxX) {
            maxX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (y > maxY) {
            maxY = y;
          }

          if (Double.isNaN(err)) {
            yIntervalSeries.add(x, y, Double.NaN, Double.NaN);
          } else {
            yIntervalSeries.add(x, y, y - err, y + err);
            hasErr = true;
          }
        }
      }

      dataset.addSeries(yIntervalSeries);

      renderer.setSeriesPaint(j, colors[j], false);
    }

    this.xyPlot.setDataset(dataset);
    
    if (!hasData) {
      return false;
    }
    
    // set shape depending on error:
    renderer.setBaseShape(getPointShape(hasErr));

    // margin:
    final double marginX = (maxX - minX) * MARGIN_PERCENTS;
    minX -= marginX;
    maxX += marginX;

    final double marginY = (maxY - minY) * MARGIN_PERCENTS;
    minY -= marginY;
    maxY += marginY;

    BoundedNumberAxis axis;

    axis = (BoundedNumberAxis) this.xyPlot.getDomainAxis();
    axis.setBounds(new Range(minX, maxX));
    axis.setRange(minX, maxX);

    axis = (BoundedNumberAxis) this.xyPlot.getRangeAxis();
    axis.setBounds(new Range(minY, maxY));
    axis.setRange(minY, maxY);
    
    return true;
  }
  
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabelMessage;
    private javax.swing.JPanel jPanelCenter;
    // End of variables declaration//GEN-END:variables
  /** drawing started time value */
  private long chartDrawStartTime = 0l;

  /**
   * Handle the chart progress event to log the chart rendering delay
   * @param event chart progress event
   */
  @Override
  public void chartProgress(final ChartProgressEvent event) {
    if (logger.isLoggable(Level.FINE)) {
      switch (event.getType()) {
        case ChartProgressEvent.DRAWING_STARTED:
          this.chartDrawStartTime = System.nanoTime();
          break;
        case ChartProgressEvent.DRAWING_FINISHED:
          logger.fine("Drawing chart time : " + 1e-6d * (System.nanoTime() - this.chartDrawStartTime) + " ms.");
          this.chartDrawStartTime = 0l;
          break;
        default:
      }
    }
    
    // Perform custom operations before/after chart rendering:
    // move JMMC annotation:
    this.aJMMC.setX(this.xyPlot.getDomainAxis().getUpperBound());
    this.aJMMC.setY(this.xyPlot.getRangeAxis().getLowerBound());
  }

  /**
   * Define the uv scaling factor
   * @param uvPlotScalingFactor new value
   */
  private void setUvPlotScalingFactor(final double uvPlotScalingFactor) {
    this.uvPlotScalingFactor = uvPlotScalingFactor;
  }

  /**
   * Convert the given value (u or v) to the plot scale
   * @param value u or v coordinate in rad-1
   * @return u or v coordinate in the plot unit
   */
  private double toUVPlotScale(final double value) {
    return this.uvPlotScalingFactor * value;
  }

  /**
   * Convert the given plot value (u or v) to the standard unit (rad-1)
   * @param value u or v coordinate in the plot unit
   * @return u or v coordinate in rad-1
   */
  private double fromUVPlotScale(final double value) {
    return value / this.uvPlotScalingFactor;
  }

  /**
   * Return the shape used to represent points on the plot
   * @param hasError flag indicating to return the shape associated to data with error or without
   * @return shape
   */
  private static Shape getPointShape(final boolean hasError) {

    if (hasError) {
      return new Rectangle2D.Double(-3d, -3d, 6d, 6d);
    }
    
    // equilateral triangle centered on its barycenter:
    final GeneralPath path = new GeneralPath();

    path.moveTo(0f, -4f);
    path.lineTo(3f, 2f);
    path.lineTo(-3f, 2f);
    path.lineTo(0f, -4f);

    return path;
  }
}
