/*******************************************************************************
 * JMMC project ( http://www.jmmc.fr ) - Copyright (C) CNRS.
 ******************************************************************************/
package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.gui.chart.AsproChartUtils;
import fr.jmmc.aspro.gui.chart.NameLabelGenerator;
import fr.jmmc.aspro.gui.chart.XYZNameDataSet;
import fr.jmmc.aspro.model.InterferometerMapData;
import fr.jmmc.aspro.model.ObservationCollectionMapData;
import fr.jmmc.aspro.model.ObservationManager;
import fr.jmmc.aspro.model.event.ObservationEvent;
import fr.jmmc.aspro.model.event.ObservationListener;
import fr.jmmc.aspro.model.oi.ObservationCollection;
import fr.jmmc.aspro.model.oi.ObservationSetting;
import fr.jmmc.aspro.service.InterferometerMapService;
import fr.jmmc.jmcs.util.NumberUtils;
import fr.jmmc.oiexplorer.core.export.DocumentExportable;
import fr.jmmc.oiexplorer.core.export.DocumentOptions;
import fr.jmmc.oiexplorer.core.gui.action.ExportDocumentAction;
import fr.jmmc.oiexplorer.core.gui.chart.ChartUtils;
import fr.jmmc.oiexplorer.core.gui.chart.FastXYBubbleRenderer;
import fr.jmmc.oiexplorer.core.gui.chart.SquareChartPanel;
import fr.jmmc.oiexplorer.core.gui.chart.SquareXYPlot;
import fr.jmmc.oiexplorer.core.gui.chart.dataset.SharedSeriesAttributes;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYTextAnnotation;
import org.jfree.chart.event.ChartProgressEvent;
import org.jfree.chart.event.ChartProgressListener;
import org.jfree.chart.labels.ItemLabelAnchor;
import org.jfree.chart.labels.ItemLabelPosition;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.ui.Drawable;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.TextAnchor;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This panel presents the interferometer plot (station, base lines ...)
 * @author bourgesl
 */
public final class InterferometerMapPanel extends javax.swing.JPanel implements ChartProgressListener,
                                                                                ObservationListener, DocumentExportable {

    /** default serial UID for Serializable interface */
    private static final long serialVersionUID = 1;
    /** Class logger */
    private static final Logger logger = LoggerFactory.getLogger(InterferometerMapPanel.class.getName());

    /* members */
    /** jFreeChart instance */
    private JFreeChart chart;
    /** xy plot instance */
    private SquareXYPlot xyPlot;
    /** JMMC annotation */
    private XYTextAnnotation aJMMC = null;
    /** current configuration to track changes */
    private String configuration = null;

    /* plot data */
    /** observation collection associated with interferometer map data */
    private ObservationCollectionMapData chartData = null;

    /* swing */
    /** chart panel */
    private SquareChartPanel chartPanel;

    /**
     * Constructor
     */
    public InterferometerMapPanel() {
        initComponents();

        postInit();
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    setLayout(new java.awt.BorderLayout());
  }// </editor-fold>//GEN-END:initComponents

    /**
     * Export the component as a document using the given action:
     * the component should check if there is something to export ?
     * @param action export action to perform the export action
     */
    @Override
    public void performAction(final ExportDocumentAction action) {
        action.process(this);
    }

    /**
     * Return the default file name
     * @param fileExtension  document's file extension
     * @return default file name
     */
    @Override
    public String getDefaultFileName(final String fileExtension) {
        if (this.getChartData() != null) {
            final StringBuilder sb = new StringBuilder(32);
            sb.append("MAP_");
            sb.append(this.getChartData().getInterferometerConfiguration(true)).append('_');
            sb.append(this.getChartData().getDisplayConfigurations("_", true)).append('.');
            sb.append(fileExtension);

            return sb.toString();
        }
        return null;
    }

    /**
     * Prepare the page layout before doing the export:
     * Performs layout and modifies the given options
     * @param options document options used to prepare the document
     */
    @Override
    public void prepareExport(final DocumentOptions options) {
        options.setSmallDefaults();
    }

    /**
     * Return the page to export given its page index
     * @param pageIndex page index (1..n)
     * @return Drawable array to export on this page
     */
    @Override
    public Drawable[] preparePage(final int pageIndex) {
        return new Drawable[]{this.chart};
    }

    /**
     * Callback indicating the export is done to reset the component's state
     */
    @Override
    public void postExport() {
        // no-op
    }

    /**
     * This method is useful to set the models and specific features of initialized swing components :
     */
    private void postInit() {

        this.chart = ChartUtils.createSquareXYLineChart(null, null, true);
        this.xyPlot = (SquareXYPlot) this.chart.getPlot();

        final XYItemRenderer lineRenderer = this.xyPlot.getRenderer();
        lineRenderer.setDefaultStroke(ChartUtils.LARGE_STROKE);

        // Use Bubble Renderer for the first dataset :
        this.xyPlot.setRenderer(0, new FastXYBubbleRenderer());

        // Use Line Renderer for the second dataset :
        this.xyPlot.setRenderer(1, lineRenderer);

        // hide axes at [0,0] :
        this.xyPlot.setDomainZeroBaselineVisible(false);
        this.xyPlot.setRangeZeroBaselineVisible(false);

        final XYItemRenderer renderer = this.xyPlot.getRenderer();

        // station labels :
        renderer.setDefaultItemLabelGenerator(new NameLabelGenerator());
        renderer.setDefaultPositiveItemLabelPosition(new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.BOTTOM_RIGHT));
        renderer.setDefaultItemLabelsVisible(true);

        // add listener :
        this.chart.addProgressListener(this);
        this.chartPanel = ChartUtils.createSquareChartPanel(this.chart);

        this.chartPanel.setMinimumSize(new Dimension(100, 100));
        this.add(this.chartPanel);
    }

    /**
     * Handle the changed event to plot the interferometer map synchronously.
     * As this instance is the first observation listener, the plot is first done
     * before other plots / computations are done.
     * @param event event
     */
    @Override
    public void onProcess(final ObservationEvent event) {
        if (logger.isDebugEnabled()) {
            logger.debug("event [{}] process IN", event.getType());
        }
        switch (event.getType()) {
            case REFRESH:
                this.plot(event.getObservationCollection());
                break;
            default:
        }
        if (logger.isDebugEnabled()) {
            logger.debug("event [{}] process OUT", event.getType());
        }
    }

    /**
     * Plot the interferometer map synchronously.
     * This code must be executed by the Swing Event Dispatcher thread (EDT)
     * @param obsCollection observation collection to use
     */
    private void plot(final ObservationCollection obsCollection) {
        if (logger.isDebugEnabled()) {
            logger.debug("plot: {}", ObservationManager.toString(obsCollection));
        }

        // create a unique key (interferometer configuration|stations...)
        // to check if the map must be refreshed
        final StringBuilder sb = new StringBuilder(64);
        sb.append(obsCollection.getInterferometerConfiguration()).append('|');
        obsCollection.getAllConfigurations(sb, "|");
        final String config = sb.toString();

        // check target versions to avoid keeping old user model references (large memory overhead due to UserModelData):
        if (getChartData() != null && !obsCollection.getVersion().isSameTargetVersion(getChartData().getVersion())) {
            logger.debug("plot : force refresh (different target versions)");
            this.configuration = null;
        }

        if (!config.equals(this.configuration)) {
            // refresh the plot :
            this.configuration = config;

            logger.debug("plot : refresh");

            final long start = System.nanoTime();

            final List<InterferometerMapData> mapDataList = new ArrayList<InterferometerMapData>(obsCollection.size());

            for (ObservationSetting observation : obsCollection.getObservations()) {
                mapDataList.add(InterferometerMapService.compute(observation));
            }

            this.updatePlot(new ObservationCollectionMapData(obsCollection, mapDataList));

            logger.info("plot : duration = {} ms.", 1e-6d * (System.nanoTime() - start));
        }
    }

    /**
     * Return the chart data
     * @return chart data
     */
    private ObservationCollectionMapData getChartData() {
        return this.chartData;
    }

    /**
     * Define the chart data
     * @param chartData chart data
     */
    private void setChartData(final ObservationCollectionMapData chartData) {
        this.chartData = chartData;
    }

    /**
     * Refresh the plot using chart data.
     * This code is executed by the Swing Event Dispatcher thread (EDT)
     *
     * @param chartData chart data
     */
    private void updatePlot(final ObservationCollectionMapData chartData) {
        // memorize chart data (used by export PDF) :
        setChartData(chartData);

        // disable chart & plot notifications:
        this.chart.setNotify(false);
        this.xyPlot.setNotify(false);
        try {
            this.xyPlot.getRenderer().removeAnnotations();
            // create new JMMC annotation (moving position):
            this.aJMMC = AsproChartUtils.createJMMCAnnotation(chartData.isConfigurationChecksumValid());
            this.xyPlot.getRenderer().addAnnotation(this.aJMMC, Layer.BACKGROUND);

            // title :
            ChartUtils.clearTextSubTitle(this.chart);

            final StringBuilder sb = new StringBuilder(32);
            sb.append(chartData.getInterferometerConfiguration(false)).append(" - ");
            sb.append(chartData.getDisplayConfigurations(" / "));

            ChartUtils.addTitle(this.chart, sb.toString());

            // computed data are valid :
            updateChart(chartData);

            // update theme at end :
            org.jfree.chart.ChartUtils.applyCurrentTheme(this.chart);

        } finally {
            // restore chart & plot notifications:
            this.xyPlot.setNotify(true);
            this.chart.setNotify(true);
        }
    }

    /**
     * Update the datasets
     * @param chartData chart data
     */
    private void updateChart(final ObservationCollectionMapData chartData) {

        // First map Data is always defined :
        final InterferometerMapData mapData1 = chartData.getFirstMapData();

        // 1 - Stations :
        // define bounds to the maximum value + 10% (before setDataset) :
        final double boxSize = mapData1.getMaxXY() * 1.10d;
        this.xyPlot.defineBounds(boxSize);

        // first plot stations :
        final XYZNameDataSet stationDataSet = new XYZNameDataSet();

        stationDataSet.addSeries("Stations", new double[][]{mapData1.getStationX(), mapData1.getStationY(), mapData1.getDiameter()}, mapData1.getStationName());

        // set the first data set :
        this.xyPlot.setDataset(stationDataSet);

        // 2 - Baselines :
        // renderer for base lines :
        final XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) this.xyPlot.getRenderer(1);

        // reset colors :
        renderer.clearSeriesPaints(false);
        // side effect with chart theme :
        renderer.setAutoPopulateSeriesPaint(false);

        // Get Global SharedSeriesAttributes:
        final SharedSeriesAttributes globalAttrs = SharedSeriesAttributes.INSTANCE;
        // reset global attributes ONCE in Aspro2:
        globalAttrs.reset();

        final XYSeriesCollection dataset = new XYSeriesCollection();

        XYSeries xySeries = null;
        String label;
        String[] blName, blLabel;
        double[] blX1, blY1, blX2, blY2;

        final boolean single = chartData.isSingle();

        // Iterate over map data (multi conf) :
        for (InterferometerMapData mapData : chartData.getMapDataList()) {
            blName = mapData.getBaselineName();
            blLabel = mapData.getBaselineLabel();
            blX1 = mapData.getBaselineStationX1();
            blY1 = mapData.getBaselineStationY1();
            blX2 = mapData.getBaselineStationX2();
            blY2 = mapData.getBaselineStationY2();

            if (!single) {
                // 1 color per configuration (i.e. per XYSeries) :
                label = mapData.getStationNames();
                // set alias = ordered station names (like OIFitsExplorer)
                globalAttrs.addLabel(label, mapData.getSortedStationConf());

                xySeries = new XYSeries(label, false);
                xySeries.setNotify(false);

                dataset.addSeries(xySeries);
            }

            for (int i = 0, len = blName.length; i < len; i++) {

                if (single) {
                    // 1 color per base line (i.e. per XYSeries) :
                    label = blLabel[i];
                    globalAttrs.addLabel(blName[i], label);
                    // Use label for the name of the serie (legend):
                    xySeries = new XYSeries(label, false);
                    xySeries.setNotify(false);

                    dataset.addSeries(xySeries);
                }

                // first station :
                xySeries.add(blX1[i], blY1[i], false);

                // second station :
                xySeries.add(blX2[i], blY2[i], false);

                // add an invalid point to break the line between the 2 segments :
                xySeries.add(NumberUtils.DBL_NAN, NumberUtils.DBL_NAN, false);

            } // BL
        }

        // Assign ONCE colors to labels automatically:
        globalAttrs.define();

        // Apply attributes to dataset:
        for (int serie = 0, seriesCount = dataset.getSeriesCount(); serie < seriesCount; serie++) {
            label = (String) dataset.getSeriesKey(serie);
            renderer.setSeriesPaint(serie, globalAttrs.getColorAlpha(label), false);
        }

        // set the second data set :
        this.xyPlot.setDataset(1, dataset);
    }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
    /** drawing started time value */
    private long chartDrawStartTime = 0l;

    /**
     * Handle the chart progress event to log the chart rendering delay
     * @param event chart progress event
     */
    @Override
    public void chartProgress(final ChartProgressEvent event) {
        if (logger.isDebugEnabled()) {
            switch (event.getType()) {
                case ChartProgressEvent.DRAWING_STARTED:
                    this.chartDrawStartTime = System.nanoTime();
                    break;
                case ChartProgressEvent.DRAWING_FINISHED:
                    logger.debug("Drawing chart time = {} ms.", 1e-6d * (System.nanoTime() - this.chartDrawStartTime));
                    this.chartDrawStartTime = 0l;
                    break;
                default:
            }
        }

        if (event.getType() == ChartProgressEvent.DRAWING_STARTED) {
            // Perform custom operations before chart rendering:
            if (this.aJMMC != null) {
                // move JMMC annotation:
                this.aJMMC.setX(this.xyPlot.getDomainAxis().getUpperBound());
                this.aJMMC.setY(this.xyPlot.getRangeAxis().getLowerBound());
            }
        }
    }
}
