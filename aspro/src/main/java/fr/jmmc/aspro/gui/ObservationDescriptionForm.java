package fr.jmmc.aspro.gui;

import fr.jmmc.aspro.model.ObservationManager;
import fr.jmmc.aspro.model.event.ObservationEvent;
import fr.jmmc.aspro.model.event.ObservationListener;
import fr.jmmc.aspro.model.oi.ObservationSetting;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author bourgesl
 */
public class ObservationDescriptionForm extends javax.swing.JPanel implements ObservationListener {

    /** default serial UID for Serializable interface */
    private static final long serialVersionUID = 1;
    /** Class logger */
    private static final Logger logger = LoggerFactory.getLogger(ObservationDescriptionForm.class.getName());
    /** observation manager */
    private final static ObservationManager om = ObservationManager.getInstance();

    /* members */
    /** flag to enable / disable the automatic update of the observation when any swing component changes */
    private boolean doAutoUpdateObservation = true;

    /** Creates new form ObservationForm */
    public ObservationDescriptionForm() {
        initComponents();

        postInit();
    }

    /**
     * This method is useful to set the specific features of initialized swing components.
     */
    private void postInit() {
        // add change listener to editable text fields :
        final DocumentListener listener = new DocumentListener() {
            @Override
            public void insertUpdate(final DocumentEvent e) {
                doUpdateObservation();
            }

            @Override
            public void removeUpdate(final DocumentEvent e) {
                doUpdateObservation();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                //Plain text components do not fire these events
            }
        };

        this.jFieldName.getDocument().addDocumentListener(listener);
        this.jTextAreaObsDesc.getDocument().addDocumentListener(listener);
    }

    /**
     * Handle the given event on the given observation.
     * Refresh the UI component according to the loaded observation settings
     *
     * @param event event
     */
    @Override
    public void onProcess(final ObservationEvent event) {
        if (logger.isDebugEnabled()) {
            logger.debug("event [{}] process IN", event.getType());
        }
        switch (event.getType()) {
            case LOADED:
                onLoadObservation(event.getObservation());
                break;
            default:
        }
        if (logger.isDebugEnabled()) {
            logger.debug("event [{}] process OUT", event.getType());
        }
    }

    /**
     * Update the UI widgets from the given loaded observation
     *
     * @param observation observation
     */
    private void onLoadObservation(final ObservationSetting observation) {
        if (logger.isDebugEnabled()) {
            logger.debug("onLoadObservation:\n{}", ObservationManager.toString(observation));
        }
        // disable the automatic update observation :
        final boolean prevAutoUpdateObservation = setAutoUpdateObservation(false);
        try {
            this.jFieldName.setText(observation.getName());
            this.jTextAreaObsDesc.setText(observation.getDescription());
        } finally {
            // restore the automatic update observation :
            setAutoUpdateObservation(prevAutoUpdateObservation);
        }
    }

    /**
     * Update the current observation (via the ObservationManager) with state of UI widgets
     */
    private void doUpdateObservation() {
        // check if the automatic update flag is enabled :
        if (doAutoUpdateObservation) {
            boolean changed = false;

            // observation :
            changed |= om.setObservationName(this.jFieldName.getText());

            changed |= om.setObservationDescription(this.jTextAreaObsDesc.getText());

            logger.debug("onUpdateObservation: changed: {}", changed);

            // Note: no event is fired
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jLabelName = new javax.swing.JLabel();
        jFieldName = new javax.swing.JTextField();
        jPanelDescription = new javax.swing.JPanel();
        jScrollPaneObsDesc = new javax.swing.JScrollPane();
        jTextAreaObsDesc = new javax.swing.JTextArea();

        setLayout(new java.awt.GridBagLayout());

        jLabelName.setText("Name");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 6, 6);
        add(jLabelName, gridBagConstraints);

        jFieldName.setColumns(5);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 6, 6);
        add(jFieldName, gridBagConstraints);

        jPanelDescription.setBorder(javax.swing.BorderFactory.createTitledBorder("Observation notes"));
        jPanelDescription.setMinimumSize(new java.awt.Dimension(10, 50));
        jPanelDescription.setPreferredSize(new java.awt.Dimension(100, 80));
        jPanelDescription.setLayout(new java.awt.GridBagLayout());

        jTextAreaObsDesc.setColumns(20);
        jTextAreaObsDesc.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jTextAreaObsDesc.setRows(1);
        jScrollPaneObsDesc.setViewportView(jTextAreaObsDesc);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        jPanelDescription.add(jScrollPaneObsDesc, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 0.8;
        add(jPanelDescription, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField jFieldName;
    private javax.swing.JLabel jLabelName;
    private javax.swing.JPanel jPanelDescription;
    private javax.swing.JScrollPane jScrollPaneObsDesc;
    private javax.swing.JTextArea jTextAreaObsDesc;
    // End of variables declaration//GEN-END:variables

    /**
     * Enable / Disable the automatic update of the observation when any swing component changes.
     * Return its previous value.
     *
     * Typical use is as following :
     * // disable the automatic update observation :
     * final boolean prevAutoUpdateObservation = setAutoUpdateObservation(false);
     * try {
     *   // operations ...
     *
     * } finally {
     *   // restore the automatic update observation :
     *   setAutoUpdateObservation(prevAutoUpdateObservation);
     * }
     *
     * @param value new value
     * @return previous value
     */
    private boolean setAutoUpdateObservation(final boolean value) {
        // first backup the state of the automatic update observation :
        final boolean previous = doAutoUpdateObservation;

        // then change its state :
        doAutoUpdateObservation = value;

        // return previous state :
        return previous;
    }
}
